{"changed":true,"filter":false,"title":"Untitled1","tooltip":"/pset3/runoff/Untitled1","value":"@app.route(\"/buy\", methods=[\"GET\", \"POST\"])\n@login_required\ndef buy():\n    \"\"\"Buy shares of stock\"\"\"\n\n    user_id = int(session.get(\"user_id\"))\n    symbol_net_share = db.execute(\"SELECT DISTINCT symbol, SUM(shares) as netshare FROM shares WHERE id = :user_id GROUP BY symbol\", user_id = user_id)\n\n\n    if request.method == \"GET\":\n        return render_template(\"buy.html\", symbol_net_share = symbol_net_share)\n\n    else:\n        if not request.form.get(\"symbol\"):\n            return apology(\"must provide stock's symbol\", 403)\n        elif lookup(request.form.get(\"symbol\")) == None:\n            return apology(\"stock does not exist\", 403)\n        elif not request.form.get(\"shares\"):\n            return apology(\"must provide stock's share\", 403)\n        elif int(request.form.get(\"shares\")) <= 0:\n            return apology(\"must provide positive integer\", 403)\n\n        #if all clear, lookup stocks\n        stocks = lookup(request.form.get(\"symbol\"))\n        #get stock price\n        price_stock = stocks[\"price\"]\n        price_stock = round(int(price_stock), 2)\n        symbol_stock = stocks[\"symbol\"]\n        name_stock = stocks[\"name\"]\n        #get no. of share\n        share_stock = int(request.form.get(\"shares\"))\n        #get total stock price\n        total_share_stock = share_stock * price_stock\n        #check with user's balance\n\n\n        balance = db.execute(\"SELECT (cash) FROM users WHERE id = :user_id\",\n                          user_id=user_id)\n        balance = balance[0][\"cash\"]\n        balance = round(balance - total_share_stock,2)\n\n        #create table if it doesnt exist\n        db.execute(\"CREATE TABLE IF NOT EXISTS shares (id INT, symbol VARCHAR(10), shares INT, price REAL, time TEXT)\")\n\n        if total_share_stock > balance:\n            return apology(\"you don't have enough money\", 403)\n        else:\n            db.execute(\"INSERT INTO shares (id, symbol, shares, price, time) VALUES (:user_id, :symbol, :shares, :price, :time)\",\n                user_id = user_id, symbol = symbol_stock, shares = share_stock, price = price_stock, time = datetime.datetime.now())\n            db.execute(\"UPDATE users SET cash = :balance WHERE id = :user_id\",\n                balance = balance, user_id = user_id)\n            return render_template(\"bought.html\", symbol_stock = symbol_stock, name_stock = name_stock,\n            share_stock = share_stock, price_stock = price_stock, total_share_stock = total_share_stock, balance = balance)\n\n\n\nvar dropdown = document.getElementById(\"dropdown\")\n\n        var typebox = document.getElementById(\"textbox\")\n\n        document.querySelector('#textbox').onkeyup = function() {\n            if (document.querySelector('#textbox').value !== '') { //if not blank, then disable dropdown\n                dropdown.disabled = true;\n            } else {\n                dropdown.disabled = false; //if textbox is blank, enable dropdown\n            }\n        }","undoManager":{"mark":-2,"position":100,"stack":[[{"start":{"row":24,"column":9},"end":{"row":25,"column":0},"action":"insert","lines":["",""],"id":4},{"start":{"row":25,"column":0},"end":{"row":25,"column":8},"action":"insert","lines":["        "]},{"start":{"row":25,"column":8},"end":{"row":26,"column":0},"action":"insert","lines":["",""]},{"start":{"row":26,"column":0},"end":{"row":26,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":26,"column":4},"end":{"row":26,"column":8},"action":"remove","lines":["    "],"id":5},{"start":{"row":26,"column":0},"end":{"row":26,"column":4},"action":"remove","lines":["    "]}],[{"start":{"row":26,"column":0},"end":{"row":40,"column":1},"action":"insert","lines":["// Record preference if vote is valid","bool vote(int voter, int rank, string name)","{","   for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j].name)==0)","        {","            preferences[voter][rank] = rank;","            printf(\"%i\\n\",preferences[voter][rank]);","            return true;","        }","    }","","    return false;","}"],"id":6}],[{"start":{"row":40,"column":1},"end":{"row":41,"column":0},"action":"insert","lines":["",""],"id":7},{"start":{"row":41,"column":0},"end":{"row":42,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":42,"column":0},"end":{"row":57,"column":1},"action":"insert","lines":["// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (candidates[j].eliminated == false)","            {","                preferences[i][j];","                candidates[j].votes++;","            }","        }","    }","    return;","}"],"id":8}],[{"start":{"row":57,"column":1},"end":{"row":58,"column":0},"action":"insert","lines":["",""],"id":9},{"start":{"row":58,"column":0},"end":{"row":59,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":59,"column":0},"end":{"row":89,"column":1},"action":"insert","lines":["int find_min(void)","{","    int min = 0;","    int last_number = candidate_count + 1;","    int arr[last_number];","    arr[last_number]=0; //initialise last number as 0. this last number will store min","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false)","        {","            arr[j] = candidates[j].votes;","            ","            if (arr[last_number] > arr[j])","            {","                arr[last_number] = arr[j];","            }","            ","            if (arr[last_number]==candidates[j].votes)","            {","                min = arr[last_number];","                printf(\"Min votes: %s,%i\\n\",candidates[j].name, min);","               ","            }","        }","","    }","    min = min + 0;","   ","    return 0;","}"],"id":10}],[{"start":{"row":89,"column":1},"end":{"row":90,"column":0},"action":"insert","lines":["",""],"id":11},{"start":{"row":90,"column":0},"end":{"row":91,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":91,"column":0},"end":{"row":112,"column":1},"action":"insert","lines":["// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    int candidate_index = 0;","    int rank1 = 0;","    int rank2 = 0;","    int rank[candidate_count];","    for (int i = 0; i < voter_count; i++) //loop through all voters","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (candidates[j].eliminated == false)","            {","                candidate_index=preferences[i][0];","                candidates[candidate_index].votes++;","            }","        }","        printf(\"Name:%s, Votes:%i\\n\",candidates[candidate_index].name,candidates[candidate_index].votes);","    }","","    return;","}"],"id":12}],[{"start":{"row":112,"column":1},"end":{"row":113,"column":0},"action":"insert","lines":["",""],"id":13},{"start":{"row":113,"column":0},"end":{"row":114,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":114,"column":0},"end":{"row":141,"column":1},"action":"insert","lines":["// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    int candidate_index = 0;","    int rank1 = 0;","    int rank2 = 0;","    int rank[candidate_count];","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated == false)","        {","            for (int i = 0; i < voter_count; i++) //loop through all voters","            {","                rank[j] = preferences[i][0];","                ","                if (rank[j] == preferences[i][0])","                {","                    candidates[rank[j]].votes++;","                }","            }","        }","    }","","    printf(\"Name:%s, Votes:%i\\n\",candidates[candidate_index].name,candidates[candidate_index].votes);","","    return;","}"],"id":14}],[{"start":{"row":141,"column":1},"end":{"row":142,"column":0},"action":"insert","lines":["",""],"id":15},{"start":{"row":142,"column":0},"end":{"row":143,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":143,"column":0},"end":{"row":152,"column":17},"action":"insert","lines":["                if (preferences[i][0]==first_preference) //looks at the candidate in first rank and count it","                {","                    candidates[first_preference].votes++;","                }","                ","                else","                {","                    rank1 = preferences[i][0]; ","                    candidates[rank1].votes++;","                }"],"id":16}],[{"start":{"row":152,"column":17},"end":{"row":153,"column":0},"action":"insert","lines":["",""],"id":17},{"start":{"row":153,"column":0},"end":{"row":153,"column":16},"action":"insert","lines":["                "]},{"start":{"row":153,"column":16},"end":{"row":154,"column":0},"action":"insert","lines":["",""]},{"start":{"row":154,"column":0},"end":{"row":154,"column":16},"action":"insert","lines":["                "]}],[{"start":{"row":154,"column":12},"end":{"row":154,"column":16},"action":"remove","lines":["    "],"id":18},{"start":{"row":154,"column":8},"end":{"row":154,"column":12},"action":"remove","lines":["    "]},{"start":{"row":154,"column":4},"end":{"row":154,"column":8},"action":"remove","lines":["    "]},{"start":{"row":154,"column":0},"end":{"row":154,"column":4},"action":"remove","lines":["    "]}],[{"start":{"row":154,"column":0},"end":{"row":169,"column":1},"action":"insert","lines":["int find_min(void)","{","","    //int arr[candidate_count]; //initialise last number as 0. this last number will store min","    int min = candidates[0].votes;","","    for (int j = 0; j < candidate_count; j++)","    {","        if (min > candidates[j].votes && candidates[j].eliminated==false)","        {","            min = candidates[j].votes;","        }","    }","    printf(\"Min votes: %i\\n\", min);","    return 0;","}"],"id":19}],[{"start":{"row":169,"column":1},"end":{"row":170,"column":0},"action":"insert","lines":["",""],"id":20},{"start":{"row":170,"column":0},"end":{"row":171,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":171,"column":0},"end":{"row":186,"column":85},"action":"insert","lines":["                int k = 0;","                while (candidates[preferences[i][k]].eliminated==true)","                {","                    candidates[preferences[i][k]].votes = 0;","                    k++;","                   ","                }","                ","                //candidates[preferences[i][k]].votes++;","                ","                if (candidates[preferences[i][0]].eliminated==false)","                {","                    candidates[preferences[i][0]].votes++;","                }                ","                ","                printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);"],"id":21}],[{"start":{"row":170,"column":0},"end":{"row":171,"column":0},"action":"insert","lines":["",""],"id":22}],[{"start":{"row":187,"column":85},"end":{"row":188,"column":0},"action":"insert","lines":["",""],"id":23},{"start":{"row":188,"column":0},"end":{"row":188,"column":16},"action":"insert","lines":["                "]},{"start":{"row":188,"column":16},"end":{"row":189,"column":0},"action":"insert","lines":["",""]},{"start":{"row":189,"column":0},"end":{"row":189,"column":16},"action":"insert","lines":["                "]}],[{"start":{"row":189,"column":12},"end":{"row":189,"column":16},"action":"remove","lines":["    "],"id":24},{"start":{"row":189,"column":8},"end":{"row":189,"column":12},"action":"remove","lines":["    "]},{"start":{"row":189,"column":4},"end":{"row":189,"column":8},"action":"remove","lines":["    "]},{"start":{"row":189,"column":0},"end":{"row":189,"column":4},"action":"remove","lines":["    "]}],[{"start":{"row":189,"column":0},"end":{"row":210,"column":1},"action":"insert","lines":["void tabulate(void)","{","    int candidate_index = 0;","    int rank1 = 0;","    int rank2 = 0;","    int rank[candidate_count];","    ","","        for (int i = 0; i < voter_count; i++) //loop through all voters","        {","            for (int j = 0; j < candidate_count; j++)","            {","                if (candidates[preferences[i][0]].eliminated==false)","                {","                    candidates[preferences[i][0]].votes++;","                }","            }","        }","    ","","    return;","}"],"id":25}],[{"start":{"row":187,"column":85},"end":{"row":188,"column":0},"action":"insert","lines":["",""],"id":26},{"start":{"row":188,"column":0},"end":{"row":188,"column":16},"action":"insert","lines":["                "]}],[{"start":{"row":211,"column":1},"end":{"row":212,"column":0},"action":"insert","lines":["",""],"id":27},{"start":{"row":212,"column":0},"end":{"row":213,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":213,"column":0},"end":{"row":231,"column":1},"action":"insert","lines":["// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        while (true)","        {","            if (min == candidates[j].votes)","            {","                return true;","            }","            ","            //return false;","","        }","","    }","    return false;","}"],"id":28}],[{"start":{"row":231,"column":1},"end":{"row":232,"column":0},"action":"insert","lines":["",""],"id":29},{"start":{"row":232,"column":0},"end":{"row":233,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":233,"column":0},"end":{"row":266,"column":1},"action":"insert","lines":["// Return the minimum number of votes any remaining candidate has","int find_min(void)","{","    int last_number = candidate_count + 1;","    int arr[last_number];","    arr[last_number] = voter_count;","    int min = 0;","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false)","        {","            arr[j] = candidates[j].votes;","        }","        ","        else","        {","            arr[j] = 0;","        }","    }","    ","    for (int j = 0; j < candidate_count; j++) ","    {","        ","        if (arr[last_number] > arr[j])","        {","            arr[last_number] = arr[j];","        }","            ","    }","    min = arr[last_number];","    printf(\"Min: %i\\n\",min);","    return 0;","}"],"id":30}],[{"start":{"row":231,"column":1},"end":{"row":232,"column":0},"action":"insert","lines":["",""],"id":31},{"start":{"row":232,"column":0},"end":{"row":233,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":233,"column":0},"end":{"row":245,"column":1},"action":"insert","lines":["// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated == false && candidates[j].votes==min)","        {","            return true;","        }","","    }","    return false;","}"],"id":32}],[{"start":{"row":280,"column":1},"end":{"row":281,"column":0},"action":"insert","lines":["",""],"id":33},{"start":{"row":281,"column":0},"end":{"row":282,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":282,"column":0},"end":{"row":313,"column":1},"action":"insert","lines":["void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        if (candidates[preferences[i][0]].eliminated == false)","        {","            candidates[preferences[i][0]].votes++;","        }","","        else","        {","            int k = 0;","            while (candidates[preferences[i][k]].eliminated==true)","            {","                candidates[preferences[i][k]].votes = 0;","                k++;","            }","            candidates[preferences[i][k]].votes++;","            printf(\"2nd Name:%s, Votes:%i\\n\",candidates[preferences[i][k]].name,candidates[preferences[i][k]].votes);","            ","        }","","    }","","    for (int j = 0; j < candidate_count; j++)","    {","        printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","    }","","","    return;","}"],"id":34}],[{"start":{"row":0,"column":0},"end":{"row":313,"column":1},"action":"remove","lines":["   // for (int i = 0; i < voter_count, i++)","  //  {","  //      for (int j = 0; j < candidate_count, j++)","   //     {","     //       if (strcmp(name, candidates[j].name)==0)","    //        {","      //          preferences[i][j] = ","     //           return true;","     //       }","   //     }","   // }","   ","   ","    // Query for each rank, for each voter count","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1); //ask for rank1, rank2 etc...","","            // Record vote, unless it's invalid","            if (!vote(i, j, name)) //if false, print invalid vote. vote must return true/false","            {","                printf(\"Invalid vote.\\n\");","                return 4;","            }","        }","        ","// Record preference if vote is valid","bool vote(int voter, int rank, string name)","{","   for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j].name)==0)","        {","            preferences[voter][rank] = rank;","            printf(\"%i\\n\",preferences[voter][rank]);","            return true;","        }","    }","","    return false;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (candidates[j].eliminated == false)","            {","                preferences[i][j];","                candidates[j].votes++;","            }","        }","    }","    return;","}","","int find_min(void)","{","    int min = 0;","    int last_number = candidate_count + 1;","    int arr[last_number];","    arr[last_number]=0; //initialise last number as 0. this last number will store min","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false)","        {","            arr[j] = candidates[j].votes;","            ","            if (arr[last_number] > arr[j])","            {","                arr[last_number] = arr[j];","            }","            ","            if (arr[last_number]==candidates[j].votes)","            {","                min = arr[last_number];","                printf(\"Min votes: %s,%i\\n\",candidates[j].name, min);","               ","            }","        }","","    }","    min = min + 0;","   ","    return 0;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    int candidate_index = 0;","    int rank1 = 0;","    int rank2 = 0;","    int rank[candidate_count];","    for (int i = 0; i < voter_count; i++) //loop through all voters","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (candidates[j].eliminated == false)","            {","                candidate_index=preferences[i][0];","                candidates[candidate_index].votes++;","            }","        }","        printf(\"Name:%s, Votes:%i\\n\",candidates[candidate_index].name,candidates[candidate_index].votes);","    }","","    return;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    int candidate_index = 0;","    int rank1 = 0;","    int rank2 = 0;","    int rank[candidate_count];","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated == false)","        {","            for (int i = 0; i < voter_count; i++) //loop through all voters","            {","                rank[j] = preferences[i][0];","                ","                if (rank[j] == preferences[i][0])","                {","                    candidates[rank[j]].votes++;","                }","            }","        }","    }","","    printf(\"Name:%s, Votes:%i\\n\",candidates[candidate_index].name,candidates[candidate_index].votes);","","    return;","}","","                if (preferences[i][0]==first_preference) //looks at the candidate in first rank and count it","                {","                    candidates[first_preference].votes++;","                }","                ","                else","                {","                    rank1 = preferences[i][0]; ","                    candidates[rank1].votes++;","                }","                ","int find_min(void)","{","","    //int arr[candidate_count]; //initialise last number as 0. this last number will store min","    int min = candidates[0].votes;","","    for (int j = 0; j < candidate_count; j++)","    {","        if (min > candidates[j].votes && candidates[j].eliminated==false)","        {","            min = candidates[j].votes;","        }","    }","    printf(\"Min votes: %i\\n\", min);","    return 0;","}","","","                int k = 0;","                while (candidates[preferences[i][k]].eliminated==true)","                {","                    candidates[preferences[i][k]].votes = 0;","                    k++;","                   ","                }","                ","                //candidates[preferences[i][k]].votes++;","                ","                if (candidates[preferences[i][0]].eliminated==false)","                {","                    candidates[preferences[i][0]].votes++;","                }                ","                ","                printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","                ","                ","void tabulate(void)","{","    int candidate_index = 0;","    int rank1 = 0;","    int rank2 = 0;","    int rank[candidate_count];","    ","","        for (int i = 0; i < voter_count; i++) //loop through all voters","        {","            for (int j = 0; j < candidate_count; j++)","            {","                if (candidates[preferences[i][0]].eliminated==false)","                {","                    candidates[preferences[i][0]].votes++;","                }","            }","        }","    ","","    return;","}","","// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        while (true)","        {","            if (min == candidates[j].votes)","            {","                return true;","            }","            ","            //return false;","","        }","","    }","    return false;","}","","// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated == false && candidates[j].votes==min)","        {","            return true;","        }","","    }","    return false;","}","","// Return the minimum number of votes any remaining candidate has","int find_min(void)","{","    int last_number = candidate_count + 1;","    int arr[last_number];","    arr[last_number] = voter_count;","    int min = 0;","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false)","        {","            arr[j] = candidates[j].votes;","        }","        ","        else","        {","            arr[j] = 0;","        }","    }","    ","    for (int j = 0; j < candidate_count; j++) ","    {","        ","        if (arr[last_number] > arr[j])","        {","            arr[last_number] = arr[j];","        }","            ","    }","    min = arr[last_number];","    printf(\"Min: %i\\n\",min);","    return 0;","}","","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        if (candidates[preferences[i][0]].eliminated == false)","        {","            candidates[preferences[i][0]].votes++;","        }","","        else","        {","            int k = 0;","            while (candidates[preferences[i][k]].eliminated==true)","            {","                candidates[preferences[i][k]].votes = 0;","                k++;","            }","            candidates[preferences[i][k]].votes++;","            printf(\"2nd Name:%s, Votes:%i\\n\",candidates[preferences[i][k]].name,candidates[preferences[i][k]].votes);","            ","        }","","    }","","    for (int j = 0; j < candidate_count; j++)","    {","        printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","    }","","","    return;","}"],"id":35},{"start":{"row":0,"column":0},"end":{"row":244,"column":0},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","","// Max voters and candidates","#define MAX_VOTERS 100","#define MAX_CANDIDATES 9","","// preferences[i][j] is jth preference for voter i","int preferences[MAX_VOTERS][MAX_CANDIDATES];","","// Candidates have name, vote count, eliminated status","typedef struct","{","    string name;","    int votes;","    bool eliminated;","}","candidate;","","// Array of candidates","candidate candidates[MAX_CANDIDATES];","","// Numbers of voters and candidates","int voter_count;","int candidate_count;","","// Function prototypes","bool vote(int voter, int rank, string name);","void tabulate(void);","bool print_winner(void);","int find_min(void);","bool is_tie(int min);","void eliminate(int min);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: runoff [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX_CANDIDATES)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX_CANDIDATES);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i].name = argv[i + 1]; //argv[1]=1st candidate's name, argv[2]=2nd candidate's name etc","        candidates[i].votes = 0;","        candidates[i].eliminated = false;","    }","","    voter_count = get_int(\"Number of voters: \");","    if (voter_count > MAX_VOTERS)","    {","        printf(\"Maximum number of voters is %i\\n\", MAX_VOTERS);","        return 3;","    }","","    // Keep querying for votes","    for (int i = 0; i < voter_count; i++)","    {","","        // Query for each rank, for each voter count","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1); //ask for rank1, rank2 etc...","","            // Record vote, unless it's invalid","            if (!vote(i, j, name)) //if false, print invalid vote. vote must return true/false","            {","                printf(\"Invalid vote.\\n\");","                return 4;","            }","        }","","        printf(\"\\n\");","    }","","    // Keep holding runoffs until winner exists","    while (true)","    {","        // Calculate votes given remaining candidates","        tabulate();","","        // Check if election has been won","        bool won = print_winner();","        if (won)","        {","            break;","        }","","        // Eliminate last-place candidates","        int min = find_min();","        //printf(\"%i\\n\",min);","        bool tie = is_tie(min);","","        // If tie, everyone wins","        if (tie)","        {","            for (int i = 0; i < candidate_count; i++)","            {","                if (!candidates[i].eliminated) //for not eliminated candidates, print their names","                {","                    printf(\"%s\\n\", candidates[i].name);","                }","            }","            break;","        }","","        // Eliminate anyone with minimum number of votes","        eliminate(min);","","        // Reset vote counts back to zero","        for (int i = 0; i < candidate_count; i++)","        {","            candidates[i].votes = 0;","        }","    }","    return 0;","}","","// Record preference if vote is valid","bool vote(int voter, int rank, string name)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j].name)==0)","        {","            preferences[voter][rank] = j;","            //printf(\"%s: %i\\n\",name,preferences[voter][rank]);","            return true;","        }","    }","    return false;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        if (candidates[preferences[i][0]].eliminated == false)","        {","            candidates[preferences[i][0]].votes++;","        }","","        else","        {","            candidates[preferences[i][1]].votes++;","        }","","    }","","    for (int j = 0; j < candidate_count; j++)","    {","        printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","    }","","","    return;","}","","// Print the winner of the election, if there is one","bool print_winner(void)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].votes > round(voter_count/2))","        {","            printf(\"%s\\n\",candidates[j].name);","            return true;","        }","","    }","    return false;","}","","// Return the minimum number of votes any remaining candidate has","int find_min(void)","{","    //int last_number = voter_count + 1;","    //int arr[last_number]; //define array that can hold 1 more than the no. of voter_count","    //arr[voter_count] = voter_count; //define last cell as max number=voter_count","    int min = 0;","    int last_number = voter_count; //initialise as the maximum number = voter_count","","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false && (last_number > candidates[j].votes))","        {","            last_number = candidates[j].votes;","            min = last_number;","        }","        min = min + 0;","    }","    printf(\"Min: %i\\n\",min);","    ","    return 0;","}","","// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    //int j = 0;","    //while (candidates[j].votes == min && j < voter_count)","    //{","       // printf(\"Tie: %i\\n\",candidates[j].votes);","       // j++;","    //}","","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated == false && candidates[j].votes==min)","        {","            return true;","        }","","    }","","    return false;","}","","// Eliminate the candidate (or candidiates) in last place","void eliminate(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (min == candidates[j].votes && candidates[j].eliminated == false)","        {","            candidates[j].eliminated = true;","            printf(\"Eliminated: %s\\n\",candidates[j].name);","        }","","    }","    return;","}",""]}],[{"start":{"row":0,"column":0},"end":{"row":244,"column":0},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","","// Max voters and candidates","#define MAX_VOTERS 100","#define MAX_CANDIDATES 9","","// preferences[i][j] is jth preference for voter i","int preferences[MAX_VOTERS][MAX_CANDIDATES];","","// Candidates have name, vote count, eliminated status","typedef struct","{","    string name;","    int votes;","    bool eliminated;","}","candidate;","","// Array of candidates","candidate candidates[MAX_CANDIDATES];","","// Numbers of voters and candidates","int voter_count;","int candidate_count;","","// Function prototypes","bool vote(int voter, int rank, string name);","void tabulate(void);","bool print_winner(void);","int find_min(void);","bool is_tie(int min);","void eliminate(int min);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: runoff [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX_CANDIDATES)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX_CANDIDATES);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i].name = argv[i + 1]; //argv[1]=1st candidate's name, argv[2]=2nd candidate's name etc","        candidates[i].votes = 0;","        candidates[i].eliminated = false;","    }","","    voter_count = get_int(\"Number of voters: \");","    if (voter_count > MAX_VOTERS)","    {","        printf(\"Maximum number of voters is %i\\n\", MAX_VOTERS);","        return 3;","    }","","    // Keep querying for votes","    for (int i = 0; i < voter_count; i++)","    {","","        // Query for each rank, for each voter count","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1); //ask for rank1, rank2 etc...","","            // Record vote, unless it's invalid","            if (!vote(i, j, name)) //if false, print invalid vote. vote must return true/false","            {","                printf(\"Invalid vote.\\n\");","                return 4;","            }","        }","","        printf(\"\\n\");","    }","","    // Keep holding runoffs until winner exists","    while (true)","    {","        // Calculate votes given remaining candidates","        tabulate();","","        // Check if election has been won","        bool won = print_winner();","        if (won)","        {","            break;","        }","","        // Eliminate last-place candidates","        int min = find_min();","        //printf(\"%i\\n\",min);","        bool tie = is_tie(min);","","        // If tie, everyone wins","        if (tie)","        {","            for (int i = 0; i < candidate_count; i++)","            {","                if (!candidates[i].eliminated) //for not eliminated candidates, print their names","                {","                    printf(\"%s\\n\", candidates[i].name);","                }","            }","            break;","        }","","        // Eliminate anyone with minimum number of votes","        eliminate(min);","","        // Reset vote counts back to zero","        for (int i = 0; i < candidate_count; i++)","        {","            candidates[i].votes = 0;","        }","    }","    return 0;","}","","// Record preference if vote is valid","bool vote(int voter, int rank, string name)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j].name)==0)","        {","            preferences[voter][rank] = j;","            //printf(\"%s: %i\\n\",name,preferences[voter][rank]);","            return true;","        }","    }","    return false;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        if (candidates[preferences[i][0]].eliminated == false)","        {","            candidates[preferences[i][0]].votes++;","        }","","        else","        {","            candidates[preferences[i][1]].votes++;","        }","","    }","","    for (int j = 0; j < candidate_count; j++)","    {","        printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","    }","","","    return;","}","","// Print the winner of the election, if there is one","bool print_winner(void)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].votes > round(voter_count/2))","        {","            printf(\"%s\\n\",candidates[j].name);","            return true;","        }","","    }","    return false;","}","","// Return the minimum number of votes any remaining candidate has","int find_min(void)","{","    //int last_number = voter_count + 1;","    //int arr[last_number]; //define array that can hold 1 more than the no. of voter_count","    //arr[voter_count] = voter_count; //define last cell as max number=voter_count","    int min = 0;","    int last_number = voter_count; //initialise as the maximum number = voter_count","","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false && (last_number > candidates[j].votes))","        {","            last_number = candidates[j].votes;","            min = last_number;","        }","        min = min + 0;","    }","    printf(\"Min: %i\\n\",min);","    ","    return 0;","}","","// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    //int j = 0;","    //while (candidates[j].votes == min && j < voter_count)","    //{","       // printf(\"Tie: %i\\n\",candidates[j].votes);","       // j++;","    //}","","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated == false && candidates[j].votes==min)","        {","            return true;","        }","","    }","","    return false;","}","","// Eliminate the candidate (or candidiates) in last place","void eliminate(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (min == candidates[j].votes && candidates[j].eliminated == false)","        {","            candidates[j].eliminated = true;","            printf(\"Eliminated: %s\\n\",candidates[j].name);","        }","","    }","    return;","}",""],"id":36},{"start":{"row":0,"column":0},"end":{"row":250,"column":0},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","","// Max voters and candidates","#define MAX_VOTERS 100","#define MAX_CANDIDATES 9","","// preferences[i][j] is jth preference for voter i","int preferences[MAX_VOTERS][MAX_CANDIDATES];","","// Candidates have name, vote count, eliminated status","typedef struct","{","    string name;","    int votes;","    bool eliminated;","}","candidate;","","// Array of candidates","candidate candidates[MAX_CANDIDATES];","","// Numbers of voters and candidates","int voter_count;","int candidate_count;","","// Function prototypes","bool vote(int voter, int rank, string name);","void tabulate(void);","bool print_winner(void);","int find_min(void);","bool is_tie(int min);","void eliminate(int min);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: runoff [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX_CANDIDATES)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX_CANDIDATES);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i].name = argv[i + 1]; //argv[1]=1st candidate's name, argv[2]=2nd candidate's name etc","        candidates[i].votes = 0;","        candidates[i].eliminated = false;","    }","","    voter_count = get_int(\"Number of voters: \");","    if (voter_count > MAX_VOTERS)","    {","        printf(\"Maximum number of voters is %i\\n\", MAX_VOTERS);","        return 3;","    }","","    // Keep querying for votes","    for (int i = 0; i < voter_count; i++)","    {","","        // Query for each rank, for each voter count","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1); //ask for rank1, rank2 etc...","","            // Record vote, unless it's invalid","            if (!vote(i, j, name)) //if false, print invalid vote. vote must return true/false","            {","                printf(\"Invalid vote.\\n\");","                return 4;","            }","        }","","        printf(\"\\n\");","    }","","    // Keep holding runoffs until winner exists","    while (true)","    {","        // Calculate votes given remaining candidates","        tabulate();","","        // Check if election has been won","        bool won = print_winner();","        if (won)","        {","            break;","        }","","        // Eliminate last-place candidates","        int min = find_min();","        //printf(\"%i\\n\",min);","        bool tie = is_tie(min);","","        // If tie, everyone wins","        if (tie)","        {","            for (int i = 0; i < candidate_count; i++)","            {","                if (!candidates[i].eliminated) //for not eliminated candidates, print their names","                {","                    printf(\"%s\\n\", candidates[i].name);","                }","            }","            break;","        }","","        // Eliminate anyone with minimum number of votes","        eliminate(min);","","        // Reset vote counts back to zero","        for (int i = 0; i < candidate_count; i++)","        {","            candidates[i].votes = 0;","        }","    }","    return 0;","}","","// Record preference if vote is valid","bool vote(int voter, int rank, string name)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j].name)==0)","        {","            preferences[voter][rank] = j;","            //printf(\"%s: %i\\n\",name,preferences[voter][rank]);","            return true;","        }","    }","    return false;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        if (candidates[preferences[i][0]].eliminated == false)","        {","            candidates[preferences[i][0]].votes++;","        }","","        else","        {","            candidates[preferences[i][1]].votes++;","        }","","    }","","    for (int j = 0; j < candidate_count; j++)","    {","        printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","    }","","","    return;","}","","// Print the winner of the election, if there is one","bool print_winner(void)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].votes > round(voter_count/2))","        {","            printf(\"%s\\n\",candidates[j].name);","            return true;","        }","","    }","    return false;","}","","// Return the minimum number of votes any remaining candidate has","int find_min(void)","{","    //int last_number = voter_count + 1;","    //int arr[last_number]; //define array that can hold 1 more than the no. of voter_count","    //arr[voter_count] = voter_count; //define last cell as max number=voter_count","    int min = 0;","    int last_number = voter_count; //initialise as the maximum number = voter_count","","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false && (last_number > candidates[j].votes))","        {","            last_number = candidates[j].votes;","            min = last_number;","        }","        min = min + 0;","    }","    printf(\"Min: %i\\n\",min);","    ","    return 0;","}","","// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    int k = 0;","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (min == candidates[j].votes && candidates[j].eliminated == false)","        {","            k = k + 0;","        }","        ","        else","        {","            k++;","        }","    }","    ","  if (k == 0)","  {","      return true;","  }","    ","    ","   return false;","","}","","// Eliminate the candidate (or candidiates) in last place","void eliminate(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (min == candidates[j].votes && candidates[j].eliminated == false)","        {","            candidates[j].eliminated = true;","            printf(\"Eliminated: %s\\n\",candidates[j].name);","        }","","    }","    return;","}",""]}],[{"start":{"row":217,"column":22},"end":{"row":217,"column":83},"action":"insert","lines":["//k will not change if all non eliminated candidates have min"],"id":37}],[{"start":{"row":222,"column":16},"end":{"row":222,"column":17},"action":"insert","lines":[" "],"id":38}],[{"start":{"row":222,"column":17},"end":{"row":222,"column":66},"action":"insert","lines":["//k will change if all candidates do not have min"],"id":39}],[{"start":{"row":0,"column":0},"end":{"row":250,"column":0},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","","// Max voters and candidates","#define MAX_VOTERS 100","#define MAX_CANDIDATES 9","","// preferences[i][j] is jth preference for voter i","int preferences[MAX_VOTERS][MAX_CANDIDATES];","","// Candidates have name, vote count, eliminated status","typedef struct","{","    string name;","    int votes;","    bool eliminated;","}","candidate;","","// Array of candidates","candidate candidates[MAX_CANDIDATES];","","// Numbers of voters and candidates","int voter_count;","int candidate_count;","","// Function prototypes","bool vote(int voter, int rank, string name);","void tabulate(void);","bool print_winner(void);","int find_min(void);","bool is_tie(int min);","void eliminate(int min);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: runoff [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX_CANDIDATES)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX_CANDIDATES);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i].name = argv[i + 1]; //argv[1]=1st candidate's name, argv[2]=2nd candidate's name etc","        candidates[i].votes = 0;","        candidates[i].eliminated = false;","    }","","    voter_count = get_int(\"Number of voters: \");","    if (voter_count > MAX_VOTERS)","    {","        printf(\"Maximum number of voters is %i\\n\", MAX_VOTERS);","        return 3;","    }","","    // Keep querying for votes","    for (int i = 0; i < voter_count; i++)","    {","","        // Query for each rank, for each voter count","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1); //ask for rank1, rank2 etc...","","            // Record vote, unless it's invalid","            if (!vote(i, j, name)) //if false, print invalid vote. vote must return true/false","            {","                printf(\"Invalid vote.\\n\");","                return 4;","            }","        }","","        printf(\"\\n\");","    }","","    // Keep holding runoffs until winner exists","    while (true)","    {","        // Calculate votes given remaining candidates","        tabulate();","","        // Check if election has been won","        bool won = print_winner();","        if (won)","        {","            break;","        }","","        // Eliminate last-place candidates","        int min = find_min();","        //printf(\"%i\\n\",min);","        bool tie = is_tie(min);","","        // If tie, everyone wins","        if (tie)","        {","            for (int i = 0; i < candidate_count; i++)","            {","                if (!candidates[i].eliminated) //for not eliminated candidates, print their names","                {","                    printf(\"%s\\n\", candidates[i].name);","                }","            }","            break;","        }","","        // Eliminate anyone with minimum number of votes","        eliminate(min);","","        // Reset vote counts back to zero","        for (int i = 0; i < candidate_count; i++)","        {","            candidates[i].votes = 0;","        }","    }","    return 0;","}","","// Record preference if vote is valid","bool vote(int voter, int rank, string name)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j].name)==0)","        {","            preferences[voter][rank] = j;","            //printf(\"%s: %i\\n\",name,preferences[voter][rank]);","            return true;","        }","    }","    return false;","}","","// Tabulate votes for non-eliminated candidates","void tabulate(void)","{","    for (int i = 0; i < voter_count; i++)","    {","        if (candidates[preferences[i][0]].eliminated == false)","        {","            candidates[preferences[i][0]].votes++;","        }","","        else","        {","            candidates[preferences[i][1]].votes++;","        }","","    }","","    for (int j = 0; j < candidate_count; j++)","    {","        printf(\"Name:%s, Votes:%i\\n\",candidates[j].name,candidates[j].votes);","    }","","","    return;","}","","// Print the winner of the election, if there is one","bool print_winner(void)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].votes > round(voter_count/2))","        {","            printf(\"%s\\n\",candidates[j].name);","            return true;","        }","","    }","    return false;","}","","// Return the minimum number of votes any remaining candidate has","int find_min(void)","{","    //int last_number = voter_count + 1;","    //int arr[last_number]; //define array that can hold 1 more than the no. of voter_count","    //arr[voter_count] = voter_count; //define last cell as max number=voter_count","    int min = 0;","    int last_number = voter_count; //initialise as the maximum number = voter_count","","    for (int j = 0; j < candidate_count; j++)","    {","        if (candidates[j].eliminated==false && (last_number > candidates[j].votes))","        {","            last_number = candidates[j].votes;","            min = last_number;","        }","        min = min + 0;","    }","    printf(\"Min: %i\\n\",min);","    ","    return 0;","}","","// Return true if the election is tied between all candidates, false otherwise","bool is_tie(int min)","{","    int k = 0;","    ","    for (int j = 0; j < candidate_count; j++)","    {","        if (min == candidates[j].votes && candidates[j].eliminated == false)","        {","            k = k + 0;//k will not change if all non eliminated candidates have min","        }","        ","        else","        {","            k++; //k will change if all candidates do not have min","        }","    }","    ","  if (k == 0)","  {","      return true;","  }","    ","    ","   return false;","","}","","// Eliminate the candidate (or candidiates) in last place","void eliminate(int min)","{","    for (int j = 0; j < candidate_count; j++)","    {","        if (min == candidates[j].votes && candidates[j].eliminated == false)","        {","            candidates[j].eliminated = true;","            printf(\"Eliminated: %s\\n\",candidates[j].name);","        }","","    }","    return;","}",""],"id":40},{"start":{"row":0,"column":0},"end":{"row":280,"column":3},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            return true;","        }","        //printf(\"Ranks: %i\\n\", ranks[j]);","    }","","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","                //printf(\"preferences:%i\\n\", preferences[ranks[i]][ranks[j]]);","            }","            printf(\"All preferences:%i\\n\", preferences[i][j]);","        }","    }","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j]!=preferences[j][i]) //preferences w count>0 & not tied","            {//preferences[i][j]!=0 &&","","                if (preferences[i][j] > preferences[j][i])","                {","                    //pairs[i].winner = preferences[i][j] - preferences[j][i]; //winner =i","                    pairs[pair_count].winner = i;","                    //pairs[j].loser = 0; //loser=j","                    pairs[pair_count].loser = j;","                }","","                else","                {","                    //pairs[j].winner = preferences[j][i] - preferences[i][j]; //winner =j","                    //pairs[i].loser = 0; //winner =i","                    pairs[pair_count].winner = j;","                    pairs[pair_count].loser = i;","                }","","                pair_count++; //do pair count later so 1st pair starts at 0.","","            }","","        }","    }","","","    printf(\"Pair count:%i\\n\",pair_count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                printf(\"Wins:%i\\n\", wins[i]);","                printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","    ","    int min = pair_count - 1; //min number is the last position of pair count","    ","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        ","        locked[w][l] = true;","    }","    ","    locked[pairs[min].winner][pairs[min].loser] = false;","    ","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        ","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"]}],[{"start":{"row":0,"column":0},"end":{"row":280,"column":3},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            return true;","        }","        //printf(\"Ranks: %i\\n\", ranks[j]);","    }","","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","                //printf(\"preferences:%i\\n\", preferences[ranks[i]][ranks[j]]);","            }","            printf(\"All preferences:%i\\n\", preferences[i][j]);","        }","    }","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j]!=preferences[j][i]) //preferences w count>0 & not tied","            {//preferences[i][j]!=0 &&","","                if (preferences[i][j] > preferences[j][i])","                {","                    //pairs[i].winner = preferences[i][j] - preferences[j][i]; //winner =i","                    pairs[pair_count].winner = i;","                    //pairs[j].loser = 0; //loser=j","                    pairs[pair_count].loser = j;","                }","","                else","                {","                    //pairs[j].winner = preferences[j][i] - preferences[i][j]; //winner =j","                    //pairs[i].loser = 0; //winner =i","                    pairs[pair_count].winner = j;","                    pairs[pair_count].loser = i;","                }","","                pair_count++; //do pair count later so 1st pair starts at 0.","","            }","","        }","    }","","","    printf(\"Pair count:%i\\n\",pair_count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                printf(\"Wins:%i\\n\", wins[i]);","                printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","    ","    int min = pair_count - 1; //min number is the last position of pair count","    ","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        ","        locked[w][l] = true;","    }","    ","    locked[pairs[min].winner][pairs[min].loser] = false;","    ","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        ","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"],"id":41},{"start":{"row":0,"column":0},"end":{"row":287,"column":3},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            return true;","        }","        //printf(\"Ranks: %i\\n\", ranks[j]);","    }","","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","                //printf(\"preferences:%i\\n\", preferences[ranks[i]][ranks[j]]);","            }","            //printf(\"All preferences:%i\\n\", preferences[i][j]);","        }","    }","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j]!=preferences[j][i]) //not tied","            {","                if (preferences[i][j] > preferences[j][i])","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    pair_count++;","                }","","                else","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    pair_count++;","                }","","                count++; //do pair count later so 1st pair starts at 0.","                //pair_count = candidate_count * (candidate_count - 1)/2;","            ","            }","            ","            else if (preferences[i][j]==preferences[j][i])","            {","                pair_count--;//this will minus 2 instead of 1","            }","        }","    }","    ","                ","","    //pair_count = candidate_count * (candidate_count - 1)/2;","    //pair_count = pair_count + count/2; //if no ties, pair_count = max*(max-1)/2","","    printf(\"Pair count:%i, Count: %i\\n\",pair_count, count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                printf(\"Wins:%i\\n\", wins[i]);","                printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","    }","","    locked[pairs[min].winner][pairs[min].loser] = false;","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"]}],[{"start":{"row":0,"column":0},"end":{"row":287,"column":3},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            return true;","        }","        //printf(\"Ranks: %i\\n\", ranks[j]);","    }","","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","                //printf(\"preferences:%i\\n\", preferences[ranks[i]][ranks[j]]);","            }","            //printf(\"All preferences:%i\\n\", preferences[i][j]);","        }","    }","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            if (preferences[i][j]!=preferences[j][i]) //not tied","            {","                if (preferences[i][j] > preferences[j][i])","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    pair_count++;","                }","","                else","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    pair_count++;","                }","","                count++; //do pair count later so 1st pair starts at 0.","                //pair_count = candidate_count * (candidate_count - 1)/2;","            ","            }","            ","            else if (preferences[i][j]==preferences[j][i])","            {","                pair_count--;//this will minus 2 instead of 1","            }","        }","    }","    ","                ","","    //pair_count = candidate_count * (candidate_count - 1)/2;","    //pair_count = pair_count + count/2; //if no ties, pair_count = max*(max-1)/2","","    printf(\"Pair count:%i, Count: %i\\n\",pair_count, count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                printf(\"Wins:%i\\n\", wins[i]);","                printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","    }","","    locked[pairs[min].winner][pairs[min].loser] = false;","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"],"id":42},{"start":{"row":0,"column":0},"end":{"row":291,"column":3},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            return true;","        }","        //printf(\"Ranks: %i\\n\", ranks[j]);","    }","","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","                //printf(\"preferences:%i\\n\", preferences[ranks[i]][ranks[j]]);","            }","            //printf(\"All preferences:%i\\n\", preferences[i][j]);","        }","    }","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","                if (preferences[i][j] > preferences[j][i]) //if not tied","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    //pair_count++;","                    count++;","                    pair_count = candidate_count * (candidate_count - 1)/2;","                    ","                }","","                else if (preferences[i][j] < preferences[j][i]) //if not tied","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    //pair_count++;","                    count++;","                    pair_count = candidate_count * (candidate_count - 1)/2;","                }","                ","                else if (preferences[i][j] == preferences[j][i]) //if tied","                {","                    pair_count--;","                    printf(\"Pair count:%i, Count: %i\\n\",pair_count, count);","                }","                //do pair count later so 1st pair starts at 0.","                //pair_count = candidate_count * (candidate_count - 1)/2;","            ","            ","        }","    }","    ","                ","","    //pair_count = candidate_count * (candidate_count - 1)/2;","    //pair_count = pair_count + count/2; //if no ties, pair_count = max*(max-1)/2","","    //printf(\"Pair count:%i, Count: %i\\n\",pair_count, count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                printf(\"Wins:%i\\n\", wins[i]);","                printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","    }","","    locked[pairs[min].winner][pairs[min].loser] = false;","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"]}],[{"start":{"row":0,"column":0},"end":{"row":291,"column":3},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            return true;","        }","        //printf(\"Ranks: %i\\n\", ranks[j]);","    }","","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","            if (i < j)","            {","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","                //printf(\"preferences:%i\\n\", preferences[ranks[i]][ranks[j]]);","            }","            //printf(\"All preferences:%i\\n\", preferences[i][j]);","        }","    }","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","","                if (preferences[i][j] > preferences[j][i]) //if not tied","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    //pair_count++;","                    count++;","                    pair_count = candidate_count * (candidate_count - 1)/2;","                    ","                }","","                else if (preferences[i][j] < preferences[j][i]) //if not tied","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    //pair_count++;","                    count++;","                    pair_count = candidate_count * (candidate_count - 1)/2;","                }","                ","                else if (preferences[i][j] == preferences[j][i]) //if tied","                {","                    pair_count--;","                    printf(\"Pair count:%i, Count: %i\\n\",pair_count, count);","                }","                //do pair count later so 1st pair starts at 0.","                //pair_count = candidate_count * (candidate_count - 1)/2;","            ","            ","        }","    }","    ","                ","","    //pair_count = candidate_count * (candidate_count - 1)/2;","    //pair_count = pair_count + count/2; //if no ties, pair_count = max*(max-1)/2","","    //printf(\"Pair count:%i, Count: %i\\n\",pair_count, count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                printf(\"Wins:%i\\n\", wins[i]);","                printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","    }","","    locked[pairs[min].winner][pairs[min].loser] = false;","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"],"id":43},{"start":{"row":0,"column":0},"end":{"row":289,"column":3},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            //printf(\"Rank%i: %i\\n\",rank, ranks[rank]);","            //printf(\"j:%i\\n\",j);","            return true;","        }","","    }","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    //int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++) //if set j = 0, it will skip the first output","        {","","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","","        }","    }","    ","   //for (int i = 0; i < candidate_count; i++)","   //{","       //for (int j = 0; j < candidate_count; j++)","       //{","           //printf(\"i:%i,j:%i. All preferences:%i\\n\", i, j,preferences[i][j]);","       //}","   //}","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++)","        {","            //pair_count = candidate_count * (candidate_count - 1)/2;","","                if (preferences[i][j] > preferences[j][i]) //if not tied","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","","                }","","                else if (preferences[i][j] < preferences[j][i]) //if not tied","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","                }","","                else if (preferences[i][j] == preferences[j][i]) //if tied","                {","                    ","                    pair_count--;","                }","        }","    }","","    printf(\"Pair_count:%i, Count%i\\n\",pair_count,count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","        printf(\"W:%i, L:%i, wins:%i\\n\",w,l,wins[i]);","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                //printf(\"Wins:%i\\n\", wins[i]);","                //printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","    }","","    locked[pairs[min].winner][pairs[min].loser] = false;","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }"]}],[{"start":{"row":289,"column":3},"end":{"row":290,"column":0},"action":"insert","lines":["",""],"id":44},{"start":{"row":290,"column":0},"end":{"row":290,"column":2},"action":"insert","lines":["  "]},{"start":{"row":290,"column":2},"end":{"row":291,"column":0},"action":"insert","lines":["",""]},{"start":{"row":291,"column":0},"end":{"row":291,"column":2},"action":"insert","lines":["  "]}],[{"start":{"row":291,"column":1},"end":{"row":291,"column":2},"action":"remove","lines":[" "],"id":45}],[{"start":{"row":291,"column":1},"end":{"row":292,"column":0},"action":"insert","lines":["",""],"id":46},{"start":{"row":292,"column":0},"end":{"row":292,"column":1},"action":"insert","lines":[" "]}],[{"start":{"row":292,"column":1},"end":{"row":332,"column":1},"action":"insert","lines":["void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","    int k = 0; //keep track of number of true","    int count = 0;","","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","","        if (pairs[min].winner==pairs[0].loser && pairs[min].loser==pairs[min-1].winner)","","        for (int j = i+1; j < pair_count; j++)","        {","            count++;","            if (locked[w][l]==locked[pairs[j].winner][pairs[j].loser])","            {","                k++;","                printf(\"k:%i\\n\",k);","            }","            ","            ","","            if (k == min)","            {","                locked[pairs[min].winner][pairs[min].loser] = false;","            }","        }","    }","","","","    return;","}"],"id":47}],[{"start":{"row":332,"column":1},"end":{"row":333,"column":0},"action":"insert","lines":["",""],"id":48},{"start":{"row":333,"column":0},"end":{"row":334,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":334,"column":0},"end":{"row":344,"column":5},"action":"insert","lines":["    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++)","        {","            if (locked[i][j]==true && locked[j][i]==true) //if candidate j is the winner","            {","                ","            }","        }","        ","    }"],"id":49}],[{"start":{"row":344,"column":5},"end":{"row":345,"column":0},"action":"insert","lines":["",""],"id":50},{"start":{"row":345,"column":0},"end":{"row":345,"column":4},"action":"insert","lines":["    "]},{"start":{"row":345,"column":4},"end":{"row":346,"column":0},"action":"insert","lines":["",""]},{"start":{"row":346,"column":0},"end":{"row":346,"column":4},"action":"insert","lines":["    "]},{"start":{"row":346,"column":4},"end":{"row":346,"column":5},"action":"insert","lines":["\\"]},{"start":{"row":346,"column":5},"end":{"row":346,"column":6},"action":"insert","lines":["\\"]}],[{"start":{"row":346,"column":5},"end":{"row":346,"column":6},"action":"remove","lines":["\\"],"id":51},{"start":{"row":346,"column":4},"end":{"row":346,"column":5},"action":"remove","lines":["\\"]},{"start":{"row":346,"column":0},"end":{"row":346,"column":4},"action":"remove","lines":["    "]},{"start":{"row":345,"column":4},"end":{"row":346,"column":0},"action":"remove","lines":["",""]}],[{"start":{"row":345,"column":4},"end":{"row":346,"column":0},"action":"insert","lines":["",""],"id":52},{"start":{"row":346,"column":0},"end":{"row":346,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":346,"column":0},"end":{"row":346,"column":4},"action":"remove","lines":["    "],"id":53}],[{"start":{"row":346,"column":0},"end":{"row":382,"column":5},"action":"insert","lines":["    for (int i = 0; i < pair_count; i++)","    {","        ","        for (int j = 0; j < pair_count; j++)","        {","            //sum[j] = sum[j] + locked[i][j];","            //printf(\"i:%i,j:%i,locked:%i\\n\",i,j,locked[i][j]); ","            //sum[i] = 0;","            sum[i] = sum[i] + locked[i][j];","            ","","        }","        //printf(\"sum[%i]:%i\\n\",i,sum[i]);//false =0; true=1","        ","    }","    ","    for (int i = 0; i < pair_count; i++)","    {","        count = sum[0];","        for (int j = 1; j < pair_count; j++)","        {","            if (sum[i]==sum[j]) ","            {","                count=0;","            }","            ","            else","            {","                count=1;","            }","        }","    }","    ","    if (count==0)","    {","        locked[pairs[min].winner][pairs[min].loser] = false;","    }"],"id":54}],[{"start":{"row":292,"column":1},"end":{"row":382,"column":5},"action":"remove","lines":["void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","    int k = 0; //keep track of number of true","    int count = 0;","","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","","        if (pairs[min].winner==pairs[0].loser && pairs[min].loser==pairs[min-1].winner)","","        for (int j = i+1; j < pair_count; j++)","        {","            count++;","            if (locked[w][l]==locked[pairs[j].winner][pairs[j].loser])","            {","                k++;","                printf(\"k:%i\\n\",k);","            }","            ","            ","","            if (k == min)","            {","                locked[pairs[min].winner][pairs[min].loser] = false;","            }","        }","    }","","","","    return;","}","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++)","        {","            if (locked[i][j]==true && locked[j][i]==true) //if candidate j is the winner","            {","                ","            }","        }","        ","    }","    ","    for (int i = 0; i < pair_count; i++)","    {","        ","        for (int j = 0; j < pair_count; j++)","        {","            //sum[j] = sum[j] + locked[i][j];","            //printf(\"i:%i,j:%i,locked:%i\\n\",i,j,locked[i][j]); ","            //sum[i] = 0;","            sum[i] = sum[i] + locked[i][j];","            ","","        }","        //printf(\"sum[%i]:%i\\n\",i,sum[i]);//false =0; true=1","        ","    }","    ","    for (int i = 0; i < pair_count; i++)","    {","        count = sum[0];","        for (int j = 1; j < pair_count; j++)","        {","            if (sum[i]==sum[j]) ","            {","                count=0;","            }","            ","            else","            {","                count=1;","            }","        }","    }","    ","    if (count==0)","    {","        locked[pairs[min].winner][pairs[min].loser] = false;","    }"],"id":55}],[{"start":{"row":292,"column":1},"end":{"row":377,"column":1},"action":"insert","lines":["// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","    int k = 0; //keep track of number of true","    int count = 0;","    int sum[pair_count];","","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (cycle(w,l)==true) //if cycle is true, do not lock","        {","            //locked[pairs[min].winner][pairs[min].loser] = false;//do not lock last pair","            locked[w][l] = false;","        }","","        else","        {","            locked[w][l] = true;","        }","","        for (int j = 0; j < pair_count; j++)","        {","            printf(\"locked:%i\\n\",locked[i][j]);","        }","        ","    }","","","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = 0; j < pair_count; j++){","","            //if (pairs[i].winner!=pairs[j].loser)","            if (locked[pairs[i].loser][pairs[j].winner]==false)","            {","                printf(\"Winner:%s\\n\",candidates[pairs[j].winner]);","            }","        }","    }","","","    return;","}","","bool cycle(int w, int l) //return true/false","{//step is the count of each joining/not joing edge process","//if every winner is also a loser then there is a cycle","//locked winner to loser= true, locked loser to winner is true also --> cycle","    if (locked[l][w]==true) //initially locked[w][l]=true","    {","        return true; //condition for recursion","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[l][i]==true) //where i is assumed to be winner","        {","            //if (cycle(l,i)==true) //if loser is winner and i is loser, check if i is checked with other candidate","            //if locked i with other winner candidate is true, return true again.","            if (cycle(i,w)==true)","            {","                return true;","            }","        }","    }","    ","    ","    return false;","","","}"],"id":56}],[{"start":{"row":0,"column":0},"end":{"row":377,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","void bubbleSort(int data[], int n);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            //printf(\"Rank%i: %i\\n\",rank, ranks[rank]);","            //printf(\"j:%i\\n\",j);","            return true;","        }","","    }","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    //int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++) //if set j = 0, it will skip the first output","        {","","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","","        }","    }","    ","   //for (int i = 0; i < candidate_count; i++)","   //{","       //for (int j = 0; j < candidate_count; j++)","       //{","           //printf(\"i:%i,j:%i. All preferences:%i\\n\", i, j,preferences[i][j]);","       //}","   //}","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++)","        {","            //pair_count = candidate_count * (candidate_count - 1)/2;","","                if (preferences[i][j] > preferences[j][i]) //if not tied","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","","                }","","                else if (preferences[i][j] < preferences[j][i]) //if not tied","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","                }","","                else if (preferences[i][j] == preferences[j][i]) //if tied","                {","                    ","                    pair_count--;","                }","        }","    }","","    printf(\"Pair_count:%i, Count%i\\n\",pair_count,count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    //where wins[w][l] = wins defined by winner and loser of each pair","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","        //wins[w][l] = preferences[w][l] - preferences[l][w]; //number of net wins","        wins[i] = preferences[w][l] - preferences[l][w];","        unsortedwins[i] = preferences[w][l] - preferences[l][w];","        printf(\"W:%i, L:%i, wins:%i\\n\",w,l,wins[i]);","    }","","    bubbleSort(wins, pair_count); //sorted wins","","    for (int i = 0; i < pair_count; i++) //keep track of wins position","    {","        for (int j = 0; j < pair_count; j++)","        {","            if (wins[i] == unsortedwins[j]) //every pair is tied to a unique win number cus win number cant be equal","            {","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","","                //printf(\"Wins:%i\\n\", wins[i]);","                //printf(\"Wins:%i\\n\", unsortedwins[j]);","            }","        }","    }","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        locked[w][l] = true;","    }","","    locked[pairs[min].winner][pairs[min].loser] = false;","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (locked[w][l]==false){","            printf(\"Winner: %s\\n\", candidates[l]);","        }","    }","    return;","}",""," // To sort the given numbers in descending order","  void bubbleSort(int data[], int n)","  {","        int temp; //temporary variable to store number","        if (n > 0)","        {","                for (int i = 0; i < n; i++)","                {","                        if (data[i] < data[i+1])","                        {","                                temp = data[i];","                                data[i] = data[i+1]; //switch larger values over to 1st position","                                data[i+1] = temp;","                        }","                }","                bubbleSort(data, n - 1);","        }","        return;","  }","  "," "," // Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","    int k = 0; //keep track of number of true","    int count = 0;","    int sum[pair_count];","","","    for (int i = 0; i < pair_count; i++)","    {","        int w = pairs[i].winner; //candidate index of winner","        int l = pairs[i].loser; //candidate index of loser","","        if (cycle(w,l)==true) //if cycle is true, do not lock","        {","            //locked[pairs[min].winner][pairs[min].loser] = false;//do not lock last pair","            locked[w][l] = false;","        }","","        else","        {","            locked[w][l] = true;","        }","","        for (int j = 0; j < pair_count; j++)","        {","            printf(\"locked:%i\\n\",locked[i][j]);","        }","        ","    }","","","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = 0; j < pair_count; j++){","","            //if (pairs[i].winner!=pairs[j].loser)","            if (locked[pairs[i].loser][pairs[j].winner]==false)","            {","                printf(\"Winner:%s\\n\",candidates[pairs[j].winner]);","            }","        }","    }","","","    return;","}","","bool cycle(int w, int l) //return true/false","{//step is the count of each joining/not joing edge process","//if every winner is also a loser then there is a cycle","//locked winner to loser= true, locked loser to winner is true also --> cycle","    if (locked[l][w]==true) //initially locked[w][l]=true","    {","        return true; //condition for recursion","    }","","    for (int i = 0; i < candidate_count; i++)","    {","        if (locked[l][i]==true) //where i is assumed to be winner","        {","            //if (cycle(l,i)==true) //if loser is winner and i is loser, check if i is checked with other candidate","            //if locked i with other winner candidate is true, return true again.","            if (cycle(i,w)==true)","            {","                return true;","            }","        }","    }","    ","    ","    return false;","","","}"],"id":57},{"start":{"row":0,"column":0},"end":{"row":319,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool cycle(int winner, int loser);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            //printf(\"Rank%i: %i\\n\",rank, ranks[rank]);","            //printf(\"j:%i\\n\",j);","            return true;","        }","","    }","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    //int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++) //if set j = 0, it will skip the first output","        {","","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","","        }","    }","","   //for (int i = 0; i < candidate_count; i++)","   //{","       //for (int j = 0; j < candidate_count; j++)","       //{","           //printf(\"i:%i,j:%i. All preferences:%i\\n\", i, j,preferences[i][j]);","       //}","   //}","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++)","        {","            //pair_count = candidate_count * (candidate_count - 1)/2;","","                if (preferences[i][j] > preferences[j][i]) //if not tied","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","","                }","","                else if (preferences[i][j] < preferences[j][i]) //if not tied","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","                }","","                else if (preferences[i][j] == preferences[j][i]) //if tied","                {","","                    pair_count--;","                }","        }","    }","","    printf(\"Pair_count:%i, Count%i\\n\",pair_count,count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    int temp_winner;","    int temp_loser;","    //where wins[w][l] = wins defined by winner and loser of each pair","","","    for (int i = 0; i < pair_count; i++)","    {","        unsortedwins[i] = preferences[pairs[i].winner][pairs[i].loser] - preferences[pairs[i].loser][pairs[i].winner];","        //printf(\"W:%i,L:%i. Unsorted:%i\\n\",pairs[i].winner,pairs[i].loser, unsortedwins[i]);","    }","","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = i+1; j < pair_count; j++)","        {","            if (unsortedwins[i]<unsortedwins[j])","            {","                temp = unsortedwins[i];","                temp_winner = pairs[i].winner;","                temp_loser = pairs[i].loser;","                unsortedwins[i] = unsortedwins[j];","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","                unsortedwins[j] = temp;","                pairs[j].winner = temp_winner;","                pairs[j].loser = temp_loser;","","            }","        }","        //printf(\"W:%i,L:%i. sorted:%i\\n\",pairs[i].winner,pairs[i].loser, unsortedwins[i]);","    }","","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","    int k = 0; //keep track of number of true","    int count = 0;","    int sum[pair_count];","","    //if (cycle(pairs[0].winner,pairs[0].loser)==false) //if no cycle","    //{","        for (int i = 0; i < pair_count; i++)","        {","            int w = pairs[i].winner; //candidate index of winner","            int l = pairs[i].loser; //candidate index of loser","            locked[w][l] = true; //lock all pairs","","            cycle(pairs[0].winner,pairs[0].loser);","","            for (int j = 0; j < pair_count; j++)","            {","                printf(\"locked:%i\\n\",locked[i][j]);","            }","        }","    //}","","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = 0; j < pair_count; j++){","","            if (pairs[i].winner!=pairs[j].loser)","            //if (locked[pairs[i].loser][pairs[j].winner]==false)","            {","                printf(\"Winner:%s\\n\",candidates[pairs[i].winner]);","            }","        }","    }","","","    return;","}","","bool cycle(int w, int l) //return true/false","{//step is the count of each joining/not joing edge process","//if every winner is also a loser then there is a cycle","//locked winner to loser= true, locked loser to winner is true also --> cycle","    if (locked[l][w]==true) //initially locked[w][l]=true","    {","        return true; //for cycle to exists w-->l must have l-->w. cycle exists","    }","","    for (int i = 0; i < pair_count; i++)//going by pair sequence","    {","        if (locked[l][pairs[i].winner]==true) //where i is assumed to be winner","        {","            //if (cycle(l,i)==true) //if loser is winner and i is loser, check if i is checked with other candidate","            //if locked i with other winner candidate is true, return true again.","            //if (cycle(i,w)==true)","            if (cycle(w,pairs[i].winner)==true) //if loser i locks onto winner then it will return true","            {","                //locked[pairs[w].winner][pairs[i].loser]==false;","                locked[pairs[i].winner][w]=false; //","                return true;","            }","        }","    }","","","    return false;","","","}"]}],[{"start":{"row":319,"column":1},"end":{"row":320,"column":0},"action":"insert","lines":["",""],"id":58},{"start":{"row":320,"column":0},"end":{"row":321,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":321,"column":0},"end":{"row":358,"column":1},"action":"insert","lines":["// Print the winner of the election","void print_winner(void)","{","    string winner;","    int wins[candidate_count];","    int sum = 0;","    int sums[candidate_count];","    int jsums[candidate_count];","    ","    ","    ","    for (int i = 0; i < candidate_count; i++)","    {","        sums[i] = 0;","        jsums[i] = 0;","        for (int j = 0; j < candidate_count; j++)","        {","            ","            sums[i] = sums[i] + locked[i][j];","            jsums[j] = jsums[j] + locked[i][j];","","        }","        printf(\"sum:%i\\n\",sums[i]);","    }","    ","    for (int i = 0; i < candidate_count; i++)","    {","       printf(\"jsums:%i\\n\",jsums[i]);","       ","       if (jsums[i]==0)","       {","           printf(\"Winner:%s\\n\",candidates[pairs[i].winner]);","       }","    }","","","    return;","}"],"id":59}],[{"start":{"row":0,"column":0},"end":{"row":358,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","// Max number of candidates","#define MAX 9","","// preferences[i][j] is number of voters who prefer i over j","int preferences[MAX][MAX]; //array","","// locked[i][j] means i is locked in over j","bool locked[MAX][MAX];","","// Each pair has a winner, loser","typedef struct","{","    int winner;","    int loser;","}","pair; //pairs[i].winner = _ ; pairs[i].loser_","","// Array of candidates","string candidates[MAX]; //name of candidates","pair pairs[MAX * (MAX - 1) / 2];","","int pair_count;","int candidate_count;","","// Function prototypes","bool vote(int rank, string name, int ranks[]);","void record_preferences(int ranks[]);","void add_pairs(void);","void sort_pairs(void);","void lock_pairs(void);","void print_winner(void);","bool cycle(int winner, int loser);","","int main(int argc, string argv[])","{","    // Check for invalid usage","    if (argc < 2)","    {","        printf(\"Usage: tideman [candidate ...]\\n\");","        return 1;","    }","","    // Populate array of candidates","    candidate_count = argc - 1;","    if (candidate_count > MAX)","    {","        printf(\"Maximum number of candidates is %i\\n\", MAX);","        return 2;","    }","    for (int i = 0; i < candidate_count; i++)","    {","        candidates[i] = argv[i + 1]; //name of candidates","    }","","    // Clear graph of locked in pairs","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = 0; j < candidate_count; j++)","        {","            locked[i][j] = false;","        }","    }","","    pair_count = 0;","    int voter_count = get_int(\"Number of voters: \");","","    // Query for votes","    for (int i = 0; i < voter_count; i++)","    {","        // ranks[i] is voter's ith preference","        int ranks[candidate_count];","","        // Query for each rank","        for (int j = 0; j < candidate_count; j++)","        {","            string name = get_string(\"Rank %i: \", j + 1);","","            if (!vote(j, name, ranks))","            {","                printf(\"Invalid vote.\\n\");","                return 3;","            }","        }","","        record_preferences(ranks);","","        printf(\"\\n\");","    }","","    add_pairs();","    sort_pairs();","    lock_pairs();","    print_winner();","    return 0;","}","","// Update ranks given a new vote","bool vote(int rank, string name, int ranks[])","{   //vote(j, name, ranks. rank=j. j=candidate_count[i]. looping over candidate","    // ranks[i] is voter's ith preference","","    for (int j = 0; j < candidate_count; j++)","    {","        if (strcmp(name, candidates[j])==0) //scan which name matches which candidate index j.","        {","            ranks[rank] = j; //index of candidate (j) is the ranks[i] for a voter","            //printf(\"Rank%i: %i\\n\",rank, ranks[rank]);","            //printf(\"j:%i\\n\",j);","            return true;","        }","","    }","","    return false;","}","","// Update preferences given one voter's ranks","void record_preferences(int ranks[])","{","    // update the global preferences array to add the current voter’s preferences.","    //preferences[i][j] should represent the number of voters who prefer candidate i over candidate j","    //int num_preference = candidate_count * (candidate_count - 1);","    //int num_preference[candidate_count][candidate_count];","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++) //if set j = 0, it will skip the first output","        {","","                preferences[ranks[i]][ranks[j]]++; //need set preferences as 0?","","        }","    }","","   //for (int i = 0; i < candidate_count; i++)","   //{","       //for (int j = 0; j < candidate_count; j++)","       //{","           //printf(\"i:%i,j:%i. All preferences:%i\\n\", i, j,preferences[i][j]);","       //}","   //}","    return;","}","","// Record pairs of candidates where one is preferred over the other","void add_pairs(void)","{","    //add all pairs of candidates where one candidate is preferred to the pairs array.","    //A pair of candidates who are tied should not be added to the array.","    //update the global variable pair_count to be the number of pairs of candidates.","    //(The pairs should thus all be stored between pairs[0] and pairs[pair_count - 1], inclusive).","    int count = 0;","","    for (int i = 0; i < candidate_count; i++)","    {","        for (int j = i+1; j < candidate_count; j++)","        {","            //pair_count = candidate_count * (candidate_count - 1)/2;","","                if (preferences[i][j] > preferences[j][i]) //if not tied","                {","                    pairs[count].winner = i;","                    pairs[count].loser = j;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","","                }","","                else if (preferences[i][j] < preferences[j][i]) //if not tied","                {","                    pairs[count].winner = j;","                    pairs[count].loser = i;","                    count++;","                    pair_count++;","                    //pair_count = candidate_count * (candidate_count - 1)/2;","                }","","                else if (preferences[i][j] == preferences[j][i]) //if tied","                {","","                    pair_count--;","                }","        }","    }","","    printf(\"Pair_count:%i, Count%i\\n\",pair_count,count);","    return;","}","","// Sort pairs in decreasing order by strength of victory //largest to smallest","void sort_pairs(void)","{","    //int wins[pair_count][pair_count];","    int unsortedwins[pair_count];","    int wins[pair_count];","    int temp; //temp variable to store ????","    int temp_winner;","    int temp_loser;","    //where wins[w][l] = wins defined by winner and loser of each pair","","","    for (int i = 0; i < pair_count; i++)","    {","        unsortedwins[i] = preferences[pairs[i].winner][pairs[i].loser] - preferences[pairs[i].loser][pairs[i].winner];","        //printf(\"W:%i,L:%i. Unsorted:%i\\n\",pairs[i].winner,pairs[i].loser, unsortedwins[i]);","    }","","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = i+1; j < pair_count; j++)","        {","            if (unsortedwins[i]<unsortedwins[j])","            {","                temp = unsortedwins[i];","                temp_winner = pairs[i].winner;","                temp_loser = pairs[i].loser;","                unsortedwins[i] = unsortedwins[j];","                pairs[i].winner = pairs[j].winner;","                pairs[i].loser = pairs[j].loser;","                unsortedwins[j] = temp;","                pairs[j].winner = temp_winner;","                pairs[j].loser = temp_loser;","","            }","        }","        //printf(\"W:%i,L:%i. sorted:%i\\n\",pairs[i].winner,pairs[i].loser, unsortedwins[i]);","    }","","","    return;","}","","// Lock pairs into the candidate graph in order, without creating cycles","void lock_pairs(void)","{","    //locked[i][j] means i is locked in over j","    //so long as the edge would not create a cycle","","    int min = pair_count - 1; //min number is the last position of pair count","    int k = 0; //keep track of number of true","    int count = 0;","    int sum[pair_count];","","    //if (cycle(pairs[0].winner,pairs[0].loser)==false) //if no cycle","    //{","        for (int i = 0; i < pair_count; i++)","        {","            int w = pairs[i].winner; //candidate index of winner","            int l = pairs[i].loser; //candidate index of loser","            locked[w][l] = true; //lock all pairs","","            cycle(pairs[0].winner,pairs[0].loser);","","            for (int j = 0; j < pair_count; j++)","            {","                printf(\"locked:%i\\n\",locked[i][j]);","            }","        }","    //}","","","    return;","}","","// Print the winner of the election","void print_winner(void)","{","    for (int i = 0; i < pair_count; i++)","    {","        for (int j = 0; j < pair_count; j++){","","            if (pairs[i].winner!=pairs[j].loser)","            //if (locked[pairs[i].loser][pairs[j].winner]==false)","            {","                printf(\"Winner:%s\\n\",candidates[pairs[i].winner]);","            }","        }","    }","","","    return;","}","","bool cycle(int w, int l) //return true/false","{//step is the count of each joining/not joing edge process","//if every winner is also a loser then there is a cycle","//locked winner to loser= true, locked loser to winner is true also --> cycle","    if (locked[l][w]==true) //initially locked[w][l]=true","    {","        return true; //for cycle to exists w-->l must have l-->w. cycle exists","    }","","    for (int i = 0; i < pair_count; i++)//going by pair sequence","    {","        if (locked[l][pairs[i].winner]==true) //where i is assumed to be winner","        {","            //if (cycle(l,i)==true) //if loser is winner and i is loser, check if i is checked with other candidate","            //if locked i with other winner candidate is true, return true again.","            //if (cycle(i,w)==true)","            if (cycle(w,pairs[i].winner)==true) //if loser i locks onto winner then it will return true","            {","                //locked[pairs[w].winner][pairs[i].loser]==false;","                locked[pairs[i].winner][w]=false; //","                return true;","            }","        }","    }","","","    return false;","","","}","","// Print the winner of the election","void print_winner(void)","{","    string winner;","    int wins[candidate_count];","    int sum = 0;","    int sums[candidate_count];","    int jsums[candidate_count];","    ","    ","    ","    for (int i = 0; i < candidate_count; i++)","    {","        sums[i] = 0;","        jsums[i] = 0;","        for (int j = 0; j < candidate_count; j++)","        {","            ","            sums[i] = sums[i] + locked[i][j];","            jsums[j] = jsums[j] + locked[i][j];","","        }","        printf(\"sum:%i\\n\",sums[i]);","    }","    ","    for (int i = 0; i < candidate_count; i++)","    {","       printf(\"jsums:%i\\n\",jsums[i]);","       ","       if (jsums[i]==0)","       {","           printf(\"Winner:%s\\n\",candidates[pairs[i].winner]);","       }","    }","","","    return;","}"],"id":60},{"start":{"row":0,"column":0},"end":{"row":138,"column":0},"action":"insert","lines":["#include \"helpers.h\"","#include <stdio.h>","#include <math.h>","#include <stdlib.h>","","// Convert image to grayscale","void grayscale(int height, int width, RGBTRIPLE image[height][width]) //RGBTRIPLE is a struc e.g. string","//image is a 2D array","{","    //int *b = malloc(24);","    //int *g = malloc(24);","    //int *r = malloc(24);","    //int *avg = malloc(24); //0;//","    int b = 0;","    int g = 0;","    int r = 0;","    int avg = 0;","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","","            b = image[i][j].rgbtBlue;","            g = image[i][j].rgbtGreen;","            r = image[i][j].rgbtRed;","","            avg = round((b + g + r)/3); //take avg of all colours then set rgb as this colour","            ","            if (avg > 255)","            {","                avg = 255;","            }","","            image[i][j].rgbtBlue = avg;","            image[i][j].rgbtGreen = avg;","            image[i][j].rgbtRed = avg;","","        }","    }","    return;","}","","// Convert image to sepia","void sepia(int height, int width, RGBTRIPLE image[height][width])","{","    int b = 0;","    int g = 0;","    int r = 0;","    int avg = 0;","    int sepiaRed = 0;","    int sepiaGreen = 0;","    int sepiaBlue = 0;","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","","            b = image[i][j].rgbtBlue;","            g = image[i][j].rgbtGreen;","            r = image[i][j].rgbtRed;","","            sepiaRed = round(.393 * r + .769 * g + .189 * b);","            sepiaGreen = round(.349 * r + .686 * g + .168 * b);","            sepiaBlue = round(.272 * r + .534 * g + .131 * b);","            ","            if (sepiaRed > 255)","            {","                sepiaRed = 255;","            }","            ","            if (sepiaGreen > 255)","            {","                sepiaGreen = 255;","            }","            ","            if (sepiaBlue > 255)","            {","                sepiaBlue = 255;","            }            ","            ","","            image[i][j].rgbtBlue = sepiaBlue;","            image[i][j].rgbtGreen = sepiaGreen;","            image[i][j].rgbtRed = sepiaRed;","            //./filter -s images/yard.bmp out.bmp","","        }","    }","    return;","}","","// Reflect image horizontally","void reflect(int height, int width, RGBTRIPLE image[height][width])","{","    ","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            int newj = width -1 - j;","            int tempBlue = 0;","            int tempGreen = 0;","            int tempRed = 0;","            //set temp variables to store initial position","            tempBlue = image[i][j].rgbtBlue;","            tempGreen = image[i][j].rgbtGreen;","            tempRed = image[i][j].rgbtRed;","            //swap","            image[i][j].rgbtBlue = image[i][newj].rgbtBlue;","            image[i][j].rgbtGreen = image[i][newj].rgbtGreen;","            image[i][j].rgbtRed = image[i][newj].rgbtRed;","            //image[i][newj].rgbtBlue = image[i][j].rgbtBlue;","            //image[i][newj].rgbtGreen = image[i][j].rgbtGreen;","            //image[i][newj].rgbtRed = image[i][j].rgbtRed;","            //assign temp to new position","            image[i][newj].rgbtBlue = tempBlue;","            image[i][newj].rgbtGreen = tempGreen;","            image[i][newj].rgbtRed = tempRed;","            ","            ","            //image[i][j].rgbtBlue = image[i][newj].rgbtBlue;","            //image[i][j].rgbtGreen = image[i][newj].rgbtGreen;","            //image[i][j].rgbtRed = image[i][newj].rgbtRed;","            //./filter -r images/yard.bmp out.bmp","","        }","    }    ","    ","    return;","}","","// Blur image","void blur(int height, int width, RGBTRIPLE image[height][width])","{","    return;","}",""]}],[{"start":{"row":136,"column":0},"end":{"row":137,"column":0},"action":"insert","lines":["",""],"id":61},{"start":{"row":137,"column":0},"end":{"row":138,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":136,"column":0},"end":{"row":154,"column":45},"action":"insert","lines":["            int b5 = image[i][j].rgbtBlue;","            int g5 = image[i][j].rgbtGreen;","            int r5 = image[i][j].rgbtRed;","            ","            int b1 = image[i-1][j-1].rgbtBlue;","            int g1 = image[i-1][j-1].rgbtGreen;","            int r1 = image[i-1][j-1].rgbtRed;","            ","            int b2 = image[i-1][j].rgbtBlue;","            int g2 = image[i-1][j].rgbtGreen;","            int r2 = image[i-1][j].rgbtRed;","            ","            int b3 = image[i-1][j+1].rgbtBlue;","            int g3 = image[i-1][j+1].rgbtGreen;","            int r3 = image[i-1][j+1].rgbtRed;              ","            ","            int b4 = image[i][j-1].rgbtBlue;","            int g4 = image[i][j-1].rgbtGreen;","            int r4 = image[i][j-1].rgbtRed;  "],"id":62}],[{"start":{"row":154,"column":45},"end":{"row":155,"column":0},"action":"insert","lines":["",""],"id":63},{"start":{"row":155,"column":0},"end":{"row":155,"column":12},"action":"insert","lines":["            "]},{"start":{"row":155,"column":12},"end":{"row":156,"column":0},"action":"insert","lines":["",""]},{"start":{"row":156,"column":0},"end":{"row":156,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":156,"column":0},"end":{"row":159,"column":25},"action":"insert","lines":["            int x1 = i-1;","            int x3 = i+1;","            int y1 = j-1;","            int y3 = j+1;"],"id":65}],[{"start":{"row":159,"column":25},"end":{"row":159,"column":37},"action":"remove","lines":["            "],"id":66},{"start":{"row":159,"column":25},"end":{"row":160,"column":0},"action":"insert","lines":["",""]},{"start":{"row":160,"column":0},"end":{"row":160,"column":12},"action":"insert","lines":["            "]},{"start":{"row":160,"column":12},"end":{"row":161,"column":0},"action":"insert","lines":["",""]},{"start":{"row":161,"column":0},"end":{"row":161,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":161,"column":0},"end":{"row":167,"column":13},"action":"insert","lines":["            for (int x = -1; x < 2; x++) //i","            {","                for (int y = -1; y < 2; y++)//j","                {","                    ","                }","            }"],"id":67}],[{"start":{"row":167,"column":13},"end":{"row":167,"column":25},"action":"remove","lines":["            "],"id":68},{"start":{"row":167,"column":13},"end":{"row":168,"column":0},"action":"insert","lines":["",""]},{"start":{"row":168,"column":0},"end":{"row":168,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":168,"column":8},"end":{"row":168,"column":12},"action":"remove","lines":["    "],"id":69},{"start":{"row":168,"column":4},"end":{"row":168,"column":8},"action":"remove","lines":["    "]},{"start":{"row":168,"column":0},"end":{"row":168,"column":4},"action":"remove","lines":["    "]}],[{"start":{"row":168,"column":0},"end":{"row":169,"column":0},"action":"insert","lines":["",""],"id":70}],[{"start":{"row":169,"column":0},"end":{"row":187,"column":15},"action":"insert","lines":["            if (i == 0) ","            {","                ","            }","","            if (i == height - 1) //last row","            {","","            }","","            if (j == 0) //first column","            {","","            }","","            if (j == width - 1) //last column","            {","","            }  "],"id":71}],[{"start":{"row":191,"column":0},"end":{"row":192,"column":0},"action":"insert","lines":["",""],"id":72}],[{"start":{"row":192,"column":0},"end":{"row":234,"column":0},"action":"insert","lines":["int nearestneighbour(int i, int j)","{","int sumb = 0;","int sumg = 0;","int sumr = 0;","","int b = 0;","int g = 0;","int r = 0;","int count = 0;","","    for (int x = -1; x < 2; x++) //i","    {","        for (int y = -1; y < 2; y++)//j","        {","            int ht = i+x;","            int hz = j+y;","            ","            if (ht>=0 && ht<height && hz>=0 && hz<width)","            {","                b = image[i+x][j+y].rgbtBlue;","                g = image[i+x][j+y].rgbtGreen;","                r = image[i+x][j+y].rgbtRed;","                ","                sumb = sumb + b;","                sumg = sumg + g;","                sumr = sumr + r;","                ","                count++;","            }","        }","    }","    ","    int avgb = round(sumb/count);","    int avgg = round(sumg/count);","    int avgr = round(sumr/count);","    ","    image[i][j].rgbtBlue = avgb;","    image[i][j].rgbtGreen = avgg;","    image[i][j].rgbtRed = avgr;","    ","}",""],"id":73}],[{"start":{"row":234,"column":0},"end":{"row":235,"column":0},"action":"insert","lines":["",""],"id":74},{"start":{"row":235,"column":0},"end":{"row":235,"column":1},"action":"insert","lines":["v"]}],[{"start":{"row":235,"column":0},"end":{"row":235,"column":1},"action":"remove","lines":["v"],"id":75}],[{"start":{"row":235,"column":0},"end":{"row":287,"column":0},"action":"insert","lines":["// Blur image","void blur(int height, int width, RGBTRIPLE image[height][width])","{","    int sumb = 0;","    int sumg = 0;","    int sumr = 0;","    int b = 0;","    int g = 0;","    int r = 0;","    ","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            int count = 0;","            ","            for (int x = -1; x < 2; x++) //i","            {","                for (int y = -1; y < 2; y++)//j","                {","                    int ht = i+x;","                    int hz = j+y;","                    ","                    if (ht>=0 && ht<height && hz>=0 && hz<width)","                    {","                        ","                        b = image[i+x][j+y].rgbtBlue;","                        g = image[i+x][j+y].rgbtGreen;","                        r = image[i+x][j+y].rgbtRed;","                        sumb = sumb + b;","                        sumg = sumg + g;","                        sumr = sumr + r;","                        count++;","                        ","                    }","                }","            }","            ","            int avgb = round(sumb/count);","            int avgg = round(sumg/count);","            int avgr = round(sumr/count);","            ","            image[i][j].rgbtBlue = avgb;","            image[i][j].rgbtGreen = avgg;","            image[i][j].rgbtRed = avgr;","    ","        }","    }","    //./filter -b images/tower.bmp out.bmp","    return;","}",""],"id":76}],[{"start":{"row":0,"column":0},"end":{"row":287,"column":0},"action":"remove","lines":["#include \"helpers.h\"","#include <stdio.h>","#include <math.h>","#include <stdlib.h>","","// Convert image to grayscale","void grayscale(int height, int width, RGBTRIPLE image[height][width]) //RGBTRIPLE is a struc e.g. string","//image is a 2D array","{","    //int *b = malloc(24);","    //int *g = malloc(24);","    //int *r = malloc(24);","    //int *avg = malloc(24); //0;//","    int b = 0;","    int g = 0;","    int r = 0;","    int avg = 0;","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","","            b = image[i][j].rgbtBlue;","            g = image[i][j].rgbtGreen;","            r = image[i][j].rgbtRed;","","            avg = round((b + g + r)/3); //take avg of all colours then set rgb as this colour","            ","            if (avg > 255)","            {","                avg = 255;","            }","","            image[i][j].rgbtBlue = avg;","            image[i][j].rgbtGreen = avg;","            image[i][j].rgbtRed = avg;","","        }","    }","    return;","}","","// Convert image to sepia","void sepia(int height, int width, RGBTRIPLE image[height][width])","{","    int b = 0;","    int g = 0;","    int r = 0;","    int avg = 0;","    int sepiaRed = 0;","    int sepiaGreen = 0;","    int sepiaBlue = 0;","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","","            b = image[i][j].rgbtBlue;","            g = image[i][j].rgbtGreen;","            r = image[i][j].rgbtRed;","","            sepiaRed = round(.393 * r + .769 * g + .189 * b);","            sepiaGreen = round(.349 * r + .686 * g + .168 * b);","            sepiaBlue = round(.272 * r + .534 * g + .131 * b);","            ","            if (sepiaRed > 255)","            {","                sepiaRed = 255;","            }","            ","            if (sepiaGreen > 255)","            {","                sepiaGreen = 255;","            }","            ","            if (sepiaBlue > 255)","            {","                sepiaBlue = 255;","            }            ","            ","","            image[i][j].rgbtBlue = sepiaBlue;","            image[i][j].rgbtGreen = sepiaGreen;","            image[i][j].rgbtRed = sepiaRed;","            //./filter -s images/yard.bmp out.bmp","","        }","    }","    return;","}","","// Reflect image horizontally","void reflect(int height, int width, RGBTRIPLE image[height][width])","{","    ","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            int newj = width -1 - j;","            int tempBlue = 0;","            int tempGreen = 0;","            int tempRed = 0;","            //set temp variables to store initial position","            tempBlue = image[i][j].rgbtBlue;","            tempGreen = image[i][j].rgbtGreen;","            tempRed = image[i][j].rgbtRed;","            //swap","            image[i][j].rgbtBlue = image[i][newj].rgbtBlue;","            image[i][j].rgbtGreen = image[i][newj].rgbtGreen;","            image[i][j].rgbtRed = image[i][newj].rgbtRed;","            //image[i][newj].rgbtBlue = image[i][j].rgbtBlue;","            //image[i][newj].rgbtGreen = image[i][j].rgbtGreen;","            //image[i][newj].rgbtRed = image[i][j].rgbtRed;","            //assign temp to new position","            image[i][newj].rgbtBlue = tempBlue;","            image[i][newj].rgbtGreen = tempGreen;","            image[i][newj].rgbtRed = tempRed;","            ","            ","            //image[i][j].rgbtBlue = image[i][newj].rgbtBlue;","            //image[i][j].rgbtGreen = image[i][newj].rgbtGreen;","            //image[i][j].rgbtRed = image[i][newj].rgbtRed;","            //./filter -r images/yard.bmp out.bmp","","        }","    }    ","    ","    return;","}","","// Blur image","void blur(int height, int width, RGBTRIPLE image[height][width])","{","            int b5 = image[i][j].rgbtBlue;","            int g5 = image[i][j].rgbtGreen;","            int r5 = image[i][j].rgbtRed;","            ","            int b1 = image[i-1][j-1].rgbtBlue;","            int g1 = image[i-1][j-1].rgbtGreen;","            int r1 = image[i-1][j-1].rgbtRed;","            ","            int b2 = image[i-1][j].rgbtBlue;","            int g2 = image[i-1][j].rgbtGreen;","            int r2 = image[i-1][j].rgbtRed;","            ","            int b3 = image[i-1][j+1].rgbtBlue;","            int g3 = image[i-1][j+1].rgbtGreen;","            int r3 = image[i-1][j+1].rgbtRed;              ","            ","            int b4 = image[i][j-1].rgbtBlue;","            int g4 = image[i][j-1].rgbtGreen;","            int r4 = image[i][j-1].rgbtRed;  ","            ","            int x1 = i-1;","            int x3 = i+1;","            int y1 = j-1;","            int y3 = j+1;","            ","            for (int x = -1; x < 2; x++) //i","            {","                for (int y = -1; y < 2; y++)//j","                {","                    ","                }","            }","","            if (i == 0) ","            {","                ","            }","","            if (i == height - 1) //last row","            {","","            }","","            if (j == 0) //first column","            {","","            }","","            if (j == width - 1) //last column","            {","","            }  ","","    return;","}","","int nearestneighbour(int i, int j)","{","int sumb = 0;","int sumg = 0;","int sumr = 0;","","int b = 0;","int g = 0;","int r = 0;","int count = 0;","","    for (int x = -1; x < 2; x++) //i","    {","        for (int y = -1; y < 2; y++)//j","        {","            int ht = i+x;","            int hz = j+y;","            ","            if (ht>=0 && ht<height && hz>=0 && hz<width)","            {","                b = image[i+x][j+y].rgbtBlue;","                g = image[i+x][j+y].rgbtGreen;","                r = image[i+x][j+y].rgbtRed;","                ","                sumb = sumb + b;","                sumg = sumg + g;","                sumr = sumr + r;","                ","                count++;","            }","        }","    }","    ","    int avgb = round(sumb/count);","    int avgg = round(sumg/count);","    int avgr = round(sumr/count);","    ","    image[i][j].rgbtBlue = avgb;","    image[i][j].rgbtGreen = avgg;","    image[i][j].rgbtRed = avgr;","    ","}","","// Blur image","void blur(int height, int width, RGBTRIPLE image[height][width])","{","    int sumb = 0;","    int sumg = 0;","    int sumr = 0;","    int b = 0;","    int g = 0;","    int r = 0;","    ","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            int count = 0;","            ","            for (int x = -1; x < 2; x++) //i","            {","                for (int y = -1; y < 2; y++)//j","                {","                    int ht = i+x;","                    int hz = j+y;","                    ","                    if (ht>=0 && ht<height && hz>=0 && hz<width)","                    {","                        ","                        b = image[i+x][j+y].rgbtBlue;","                        g = image[i+x][j+y].rgbtGreen;","                        r = image[i+x][j+y].rgbtRed;","                        sumb = sumb + b;","                        sumg = sumg + g;","                        sumr = sumr + r;","                        count++;","                        ","                    }","                }","            }","            ","            int avgb = round(sumb/count);","            int avgg = round(sumg/count);","            int avgr = round(sumr/count);","            ","            image[i][j].rgbtBlue = avgb;","            image[i][j].rgbtGreen = avgg;","            image[i][j].rgbtRed = avgr;","    ","        }","    }","    //./filter -b images/tower.bmp out.bmp","    return;","}",""],"id":77},{"start":{"row":0,"column":0},"end":{"row":252,"column":0},"action":"insert","lines":["#include \"helpers.h\"","#include <stdio.h>","#include <math.h>","#include <stdlib.h>","","// Convert image to grayscale","void grayscale(int height, int width, RGBTRIPLE image[height][width])","{","    int b = 0;","    int g = 0;","    int r = 0;","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","","            b = image[i][j].rgbtBlue;","            g = image[i][j].rgbtGreen;","            r = image[i][j].rgbtRed;","","            float avg = (b + g + r)/3.0; //must use 3.0 instead of 3 when assigning as float.","            //if not it will round down for u instead of rounding up","","            if (avg > 255)","            {","                avg = 255;","            }","","            image[i][j].rgbtBlue = round(avg);","            image[i][j].rgbtGreen = round(avg);","            image[i][j].rgbtRed = round(avg);","","        }","    }","    return;","}","","// Reflect image horizontally","void reflect(int height, int width, RGBTRIPLE image[height][width])","{","    for (int i = 0; i < height; i++)","    {","        int halfwidth = 0;","        halfwidth = floor(width/2);","","        for (int j = 0; j < halfwidth; j++)","        {","            int newj = width -1 - j;","            int tempBlue = 0;","            int tempGreen = 0;","            int tempRed = 0;","            //set temp variables to store initial position","            tempBlue = image[i][j].rgbtBlue;","            tempGreen = image[i][j].rgbtGreen;","            tempRed = image[i][j].rgbtRed;","            //swap","            image[i][j].rgbtBlue = image[i][newj].rgbtBlue;","            image[i][j].rgbtGreen = image[i][newj].rgbtGreen;","            image[i][j].rgbtRed = image[i][newj].rgbtRed;","","            //assign temp to new position","            image[i][newj].rgbtBlue = tempBlue;","            image[i][newj].rgbtGreen = tempGreen;","            image[i][newj].rgbtRed = tempRed;","","            //./filter -r images/tower.bmp out.bmp","        }","    }","    return;","}","","// Blur image","void blur(int height, int width, RGBTRIPLE image[height][width])","{","    RGBTRIPLE newimage[height][width];","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            float count = 0;","            float sumb = 0;","            float sumg = 0;","            float sumr = 0;","","            for (int x = -1; x < 2; x++) //i","            {","","                for (int y = -1; y < 2; y++)//j //is this necessary? put between i & j?","                {","                    int ht = i+x;//height","                    int hz = j+y; //width","","                    if (ht >= 0 && ht < height && hz >= 0 && hz < width)","                    {","","                        int b = image[ht][hz].rgbtBlue;","                        int g = image[ht][hz].rgbtGreen;","                        int r = image[ht][hz].rgbtRed;","                        sumb = sumb + b;","                        sumg = sumg + g;","                        sumr = sumr + r;","                        count++; //count may be correct","","                    }","                }","","            }","","            int avgb = round(sumb/count); // will lead to rounding down problems again","            int avgg = round(sumg/count);// need to change count to float","            int avgr = round(sumr/count);","","            newimage[i][j].rgbtBlue = avgb; //do not assign to ij will be replaced with the avg values","            newimage[i][j].rgbtGreen = avgg;//avg values will be used in the next calculation of pixels","            newimage[i][j].rgbtRed = avgr; //only assign values AFTER all avg has been computed","","        }","    }","    //./filter -b images/yard.bmp out.bmp","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            image[i][j].rgbtBlue = newimage[i][j].rgbtBlue;","            image[i][j].rgbtGreen = newimage[i][j].rgbtGreen;","            image[i][j].rgbtRed = newimage[i][j].rgbtRed;","        }","    }","    return;","}","","// Detect edges","void edges(int height, int width, RGBTRIPLE image[height][width])","{","    RGBTRIPLE newimage[height][width];","    int Gx[3][3] = {{-1,0,1},{-2,0,2},{-1,0,1}};","    int Gy[3][3] = {{-1,-2,-1},{0,0,0},{1,2,1}};","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            //sum of gx kernal","            int sumgxb = 0;","            int sumgxg = 0;","            int sumgxr = 0;","            //sum of gy kernal","            int sumgyb = 0;","            int sumgyg = 0;","            int sumgyr = 0;","            ","            for (int x = -1; x < 2; x++) //i","            {","","                for (int y = -1; y < 2; y++)//j //is this necessary? put between i & j?","                {","                    int ht = i+x;//height","                    int hz = j+y; //width","","                    int kht = 1+x; //kernal height","                    int khz = 1+y; //kernal width","","                    //colours of each pixel","                    int b = 0;","                    int g = 0;","                    int r = 0;","                    //weighted pixels for Gx","                    int gxb = 0;","                    int gxg = 0;","                    int gxr = 0;","                    ","                    //weighted pixels for Gy","                    int gyb = 0;","                    int gyg = 0;","                    int gyr = 0;                    ","","                    if (ht >= 0 && ht < height && hz >= 0 && hz < width) //for kernal within image boundary","                    {","                        b = image[ht][hz].rgbtBlue;","                        g = image[ht][hz].rgbtGreen;","                        r = image[ht][hz].rgbtRed;","                    }","","                    else //for kernal exceeding image boundary","                    {","                        b = 0;","                        g = 0;","                        r = 0;","                    }","","                        gxb = b*Gx[kht][khz];","                        gxg = g*Gx[kht][khz];","                        gxr = r*Gx[kht][khz];","                        ","                        gyb = b*Gy[kht][khz];","                        gyg = g*Gy[kht][khz];","                        gyr = r*Gy[kht][khz];","","                        sumgxb = sumgxb + gxb;","                        sumgxg = sumgxg + gxg;","                        sumgxr = sumgxr + gxr;","","                        sumgyb = sumgyb + gyb;","                        sumgyg = sumgyg + gyg;","                        sumgyr = sumgyr + gyr;                        ","                }","","            }","            ","            int finalb = sqrt(pow(sumgxb,2) + pow(sumgyb,2));","            int finalg = sqrt(pow(sumgxg,2) + pow(sumgyg,2));","            int finalr = sqrt(pow(sumgxr,2) + pow(sumgyr,2));","            ","            if (finalb > 255)","            {","                finalb = 255;","            }","            ","            if (finalg > 255)","            {","                finalg = 255;","            }","            ","            if (finalr > 255)","            {","                finalr = 255;","            }","","            newimage[i][j].rgbtBlue = finalb; //do not assign to ij will be replaced with the avg values","            newimage[i][j].rgbtGreen = finalg;//avg values will be used in the next calculation of pixels","            newimage[i][j].rgbtRed = finalr; //only assign values AFTER all avg has been computed","","        }","    }","    ","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            image[i][j].rgbtBlue = newimage[i][j].rgbtBlue;","            image[i][j].rgbtGreen = newimage[i][j].rgbtGreen;","            image[i][j].rgbtRed = newimage[i][j].rgbtRed;","        }","    }","    ","    //./filter -e yard.bmp out.bmp","    return;","}",""]}],[{"start":{"row":0,"column":0},"end":{"row":252,"column":0},"action":"remove","lines":["#include \"helpers.h\"","#include <stdio.h>","#include <math.h>","#include <stdlib.h>","","// Convert image to grayscale","void grayscale(int height, int width, RGBTRIPLE image[height][width])","{","    int b = 0;","    int g = 0;","    int r = 0;","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","","            b = image[i][j].rgbtBlue;","            g = image[i][j].rgbtGreen;","            r = image[i][j].rgbtRed;","","            float avg = (b + g + r)/3.0; //must use 3.0 instead of 3 when assigning as float.","            //if not it will round down for u instead of rounding up","","            if (avg > 255)","            {","                avg = 255;","            }","","            image[i][j].rgbtBlue = round(avg);","            image[i][j].rgbtGreen = round(avg);","            image[i][j].rgbtRed = round(avg);","","        }","    }","    return;","}","","// Reflect image horizontally","void reflect(int height, int width, RGBTRIPLE image[height][width])","{","    for (int i = 0; i < height; i++)","    {","        int halfwidth = 0;","        halfwidth = floor(width/2);","","        for (int j = 0; j < halfwidth; j++)","        {","            int newj = width -1 - j;","            int tempBlue = 0;","            int tempGreen = 0;","            int tempRed = 0;","            //set temp variables to store initial position","            tempBlue = image[i][j].rgbtBlue;","            tempGreen = image[i][j].rgbtGreen;","            tempRed = image[i][j].rgbtRed;","            //swap","            image[i][j].rgbtBlue = image[i][newj].rgbtBlue;","            image[i][j].rgbtGreen = image[i][newj].rgbtGreen;","            image[i][j].rgbtRed = image[i][newj].rgbtRed;","","            //assign temp to new position","            image[i][newj].rgbtBlue = tempBlue;","            image[i][newj].rgbtGreen = tempGreen;","            image[i][newj].rgbtRed = tempRed;","","            //./filter -r images/tower.bmp out.bmp","        }","    }","    return;","}","","// Blur image","void blur(int height, int width, RGBTRIPLE image[height][width])","{","    RGBTRIPLE newimage[height][width];","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            float count = 0;","            float sumb = 0;","            float sumg = 0;","            float sumr = 0;","","            for (int x = -1; x < 2; x++) //i","            {","","                for (int y = -1; y < 2; y++)//j //is this necessary? put between i & j?","                {","                    int ht = i+x;//height","                    int hz = j+y; //width","","                    if (ht >= 0 && ht < height && hz >= 0 && hz < width)","                    {","","                        int b = image[ht][hz].rgbtBlue;","                        int g = image[ht][hz].rgbtGreen;","                        int r = image[ht][hz].rgbtRed;","                        sumb = sumb + b;","                        sumg = sumg + g;","                        sumr = sumr + r;","                        count++; //count may be correct","","                    }","                }","","            }","","            int avgb = round(sumb/count); // will lead to rounding down problems again","            int avgg = round(sumg/count);// need to change count to float","            int avgr = round(sumr/count);","","            newimage[i][j].rgbtBlue = avgb; //do not assign to ij will be replaced with the avg values","            newimage[i][j].rgbtGreen = avgg;//avg values will be used in the next calculation of pixels","            newimage[i][j].rgbtRed = avgr; //only assign values AFTER all avg has been computed","","        }","    }","    //./filter -b images/yard.bmp out.bmp","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            image[i][j].rgbtBlue = newimage[i][j].rgbtBlue;","            image[i][j].rgbtGreen = newimage[i][j].rgbtGreen;","            image[i][j].rgbtRed = newimage[i][j].rgbtRed;","        }","    }","    return;","}","","// Detect edges","void edges(int height, int width, RGBTRIPLE image[height][width])","{","    RGBTRIPLE newimage[height][width];","    int Gx[3][3] = {{-1,0,1},{-2,0,2},{-1,0,1}};","    int Gy[3][3] = {{-1,-2,-1},{0,0,0},{1,2,1}};","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            //sum of gx kernal","            int sumgxb = 0;","            int sumgxg = 0;","            int sumgxr = 0;","            //sum of gy kernal","            int sumgyb = 0;","            int sumgyg = 0;","            int sumgyr = 0;","            ","            for (int x = -1; x < 2; x++) //i","            {","","                for (int y = -1; y < 2; y++)//j //is this necessary? put between i & j?","                {","                    int ht = i+x;//height","                    int hz = j+y; //width","","                    int kht = 1+x; //kernal height","                    int khz = 1+y; //kernal width","","                    //colours of each pixel","                    int b = 0;","                    int g = 0;","                    int r = 0;","                    //weighted pixels for Gx","                    int gxb = 0;","                    int gxg = 0;","                    int gxr = 0;","                    ","                    //weighted pixels for Gy","                    int gyb = 0;","                    int gyg = 0;","                    int gyr = 0;                    ","","                    if (ht >= 0 && ht < height && hz >= 0 && hz < width) //for kernal within image boundary","                    {","                        b = image[ht][hz].rgbtBlue;","                        g = image[ht][hz].rgbtGreen;","                        r = image[ht][hz].rgbtRed;","                    }","","                    else //for kernal exceeding image boundary","                    {","                        b = 0;","                        g = 0;","                        r = 0;","                    }","","                        gxb = b*Gx[kht][khz];","                        gxg = g*Gx[kht][khz];","                        gxr = r*Gx[kht][khz];","                        ","                        gyb = b*Gy[kht][khz];","                        gyg = g*Gy[kht][khz];","                        gyr = r*Gy[kht][khz];","","                        sumgxb = sumgxb + gxb;","                        sumgxg = sumgxg + gxg;","                        sumgxr = sumgxr + gxr;","","                        sumgyb = sumgyb + gyb;","                        sumgyg = sumgyg + gyg;","                        sumgyr = sumgyr + gyr;                        ","                }","","            }","            ","            int finalb = sqrt(pow(sumgxb,2) + pow(sumgyb,2));","            int finalg = sqrt(pow(sumgxg,2) + pow(sumgyg,2));","            int finalr = sqrt(pow(sumgxr,2) + pow(sumgyr,2));","            ","            if (finalb > 255)","            {","                finalb = 255;","            }","            ","            if (finalg > 255)","            {","                finalg = 255;","            }","            ","            if (finalr > 255)","            {","                finalr = 255;","            }","","            newimage[i][j].rgbtBlue = finalb; //do not assign to ij will be replaced with the avg values","            newimage[i][j].rgbtGreen = finalg;//avg values will be used in the next calculation of pixels","            newimage[i][j].rgbtRed = finalr; //only assign values AFTER all avg has been computed","","        }","    }","    ","","    for (int i = 0; i < height; i++)","    {","        for (int j = 0; j < width; j++)","        {","            image[i][j].rgbtBlue = newimage[i][j].rgbtBlue;","            image[i][j].rgbtGreen = newimage[i][j].rgbtGreen;","            image[i][j].rgbtRed = newimage[i][j].rgbtRed;","        }","    }","    ","    //./filter -e yard.bmp out.bmp","    return;","}",""],"id":78},{"start":{"row":0,"column":0},"end":{"row":66,"column":0},"action":"insert","lines":["bool findblocks(int *buffer, FILE *file)","{","    if (fread(buffer,512,blocks,file) < blocks)","    {","        //printf(\"blocks:%i\",blocks);","        blocks = blocks+0;","        return false;","    }","","    ","    if (findblocks(buffer, file)==true)","    {","        if (fread(buffer,512,blocks,file) == blocks)","        {","            //printf(\"blocks:%i\",blocks);","            blocks++;","        }","    }","    printf(\"blocks:%i\",blocks);","    return true;","}","","void recursion(int *buffer)","{","","//if first jpeg file","    if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)","    {","        //fread(); //keep reading blocks of 512B until u find another jpeg header file","        //fread(data,size,number,inptr)","        //fread(buffer, 512, 1, file);","        //fclose(); //close file","","        //create a newfile name","        char *filename = malloc(sizeof(char*));","        //update file name with count of jpegs u have found so far","        sprintf(filename,\"%03i.jpg\",count);","        //start to write data to newfile","        FILE *img = fopen(filename, \"w\");","        fwrite(buffer,512,1,img); //number of 512 blocks to read depends on the location of next header files","        //fwrite(data,size,number,outptr)","        //close the file and continue writing","    }","","    else //if header files of jpg not found, free memory space of buffer","    {","        free(buffer);","    }","","//if not first jpg, continue reading until end of card","    //keep looping size of buffer until end of card","    //with every buffer, read the first 4 bytes to check for jpeg","    //buffer[0] == 0xff","    //buffer[1] == 0xd8","    //buffer[2] == 0xff","    //malloc sizeof bytes for new filename for writing a new jpeg","    //filename should be e.g. 001.jpeg","    //keep track of count for every found jpeg then write it to filename","    //if first jpeg is found --> write a new jpeg file and name it (rmb malloc)","    //sprintf","    //else go to next buffer and look for jpeg","    //if already found jpeg, continue reading it cus a JPEG may take up more than 1 buffer block","    //continue reading block until u find the next JPEG header,","    //once found a new JPEG header, close the prev jpeg file and fopen and fwrite again...","    //end of memory card -> close remaining files","    //may need while loop or do this recursively since jpegs are stored back to back",""]}],[{"start":{"row":66,"column":0},"end":{"row":67,"column":0},"action":"insert","lines":["",""],"id":79}],[{"start":{"row":67,"column":0},"end":{"row":86,"column":55},"action":"insert","lines":["    while (fread(buffer,512,blocks,file)==blocks)","    {","        //if jpeg is found","        if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)","        {","        //create a newfile name","        //char *filename = malloc(sizeof(char*));","        //update file name with count of jpegs u have found so far","        //sprintf(filename,\"%03i.jpg\",count);","        //start to write data to newfile","        //FILE *img = fopen(filename, \"w\");","        //fwrite(buffer,512,1,img); //number of 512 blocks to read depends on the location of next header files","        //close the file and continue writing","        }   ","    ","        blocks++;","        buffer = malloc(blocks*512);","    }","","    printf(\"blocks:%i\\n\",blocks); //121 blocks in total"],"id":80}],[{"start":{"row":86,"column":55},"end":{"row":87,"column":0},"action":"insert","lines":["",""],"id":81},{"start":{"row":87,"column":0},"end":{"row":87,"column":4},"action":"insert","lines":["    "]},{"start":{"row":87,"column":4},"end":{"row":88,"column":0},"action":"insert","lines":["",""]},{"start":{"row":88,"column":0},"end":{"row":88,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":88,"column":0},"end":{"row":93,"column":5},"action":"insert","lines":["    int fileSize = ftell(file); //identify end of memory card in terms of bytes","    ","    for (int i = 0; i<fileSize; i+=512) //loop through the memory card 512 bytes at a time","    {","        while (fread(byte,512,blocks,file)==blocks)","    }"],"id":83}],[{"start":{"row":0,"column":0},"end":{"row":93,"column":9},"action":"remove","lines":["bool findblocks(int *buffer, FILE *file)","{","    if (fread(buffer,512,blocks,file) < blocks)","    {","        //printf(\"blocks:%i\",blocks);","        blocks = blocks+0;","        return false;","    }","","    ","    if (findblocks(buffer, file)==true)","    {","        if (fread(buffer,512,blocks,file) == blocks)","        {","            //printf(\"blocks:%i\",blocks);","            blocks++;","        }","    }","    printf(\"blocks:%i\",blocks);","    return true;","}","","void recursion(int *buffer)","{","","//if first jpeg file","    if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)","    {","        //fread(); //keep reading blocks of 512B until u find another jpeg header file","        //fread(data,size,number,inptr)","        //fread(buffer, 512, 1, file);","        //fclose(); //close file","","        //create a newfile name","        char *filename = malloc(sizeof(char*));","        //update file name with count of jpegs u have found so far","        sprintf(filename,\"%03i.jpg\",count);","        //start to write data to newfile","        FILE *img = fopen(filename, \"w\");","        fwrite(buffer,512,1,img); //number of 512 blocks to read depends on the location of next header files","        //fwrite(data,size,number,outptr)","        //close the file and continue writing","    }","","    else //if header files of jpg not found, free memory space of buffer","    {","        free(buffer);","    }","","//if not first jpg, continue reading until end of card","    //keep looping size of buffer until end of card","    //with every buffer, read the first 4 bytes to check for jpeg","    //buffer[0] == 0xff","    //buffer[1] == 0xd8","    //buffer[2] == 0xff","    //malloc sizeof bytes for new filename for writing a new jpeg","    //filename should be e.g. 001.jpeg","    //keep track of count for every found jpeg then write it to filename","    //if first jpeg is found --> write a new jpeg file and name it (rmb malloc)","    //sprintf","    //else go to next buffer and look for jpeg","    //if already found jpeg, continue reading it cus a JPEG may take up more than 1 buffer block","    //continue reading block until u find the next JPEG header,","    //once found a new JPEG header, close the prev jpeg file and fopen and fwrite again...","    //end of memory card -> close remaining files","    //may need while loop or do this recursively since jpegs are stored back to back","","    while (fread(buffer,512,blocks,file)==blocks)","    {","        //if jpeg is found","        if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)","        {","        //create a newfile name","        //char *filename = malloc(sizeof(char*));","        //update file name with count of jpegs u have found so far","        //sprintf(filename,\"%03i.jpg\",count);","        //start to write data to newfile","        //FILE *img = fopen(filename, \"w\");","        //fwrite(buffer,512,1,img); //number of 512 blocks to read depends on the location of next header files","        //close the file and continue writing","        }   ","    ","        blocks++;","        buffer = malloc(blocks*512);","    }","","    printf(\"blocks:%i\\n\",blocks); //121 blocks in total","    ","    int fileSize = ftell(file); //identify end of memory card in terms of bytes","    ","    for (int i = 0; i<fileSize; i+=512) //loop through the memory card 512 bytes at a time","    {","        while (fread(byte,512,blocks,file)==blocks)","    }    "],"id":84},{"start":{"row":0,"column":0},"end":{"row":81,"column":1},"action":"insert","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","//global variables","//int blocks = 1;","int count = 0;","","//functions","void recursion(int *buffer);","bool findblocks(int *buffer, FILE *file);","","int main(int argc, char *argv[])","{","    // Check usage","    if (argc != 2)","    {","        printf(\"Usage: %s image\\n\", argv[0]);","        return 1;","    }","","    int blocks = 1;","    //int *buffer = malloc(blocks*512); //malloc 512 bytes into buffer to temp store data first","    unsigned char buffer[512]; //buffer array holding 512 bytes","    char filename[8];","","    // Open file","    FILE *file = fopen(argv[1], \"r\");","","    if (!file)","    {","        printf(\"Unable to open file!\");","        return 1;","    }","","    bool firstjpg = true;","    bool jpgexists = false;","    FILE *img = NULL;","","    while(fread(buffer,512,blocks,file)==blocks)","    {","","        if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)","        {","","            if (firstjpg == true) //if it is the first jpeg","            {","                firstjpg = false;","                jpgexists = true;","            }","","            else //if firstjpg = false;","            {","                fclose(img); //if jpg exists and another jpg header is found, close previous one","                firstjpg = false;","                jpgexists = true;","            }","","","            sprintf(filename,\"%03i.jpg\",count);","            img = fopen(filename, \"w\"); //open file","            fwrite(buffer,512,1,img); //write data to it","            count++; //increase count only if header jpg are found //update with new count","","        }","","        else //if jpg header files not found","        {","            if (jpgexists == true) //& if jpg alr exists","            {","                fwrite(buffer,512,1,img); //continue writing to img","            }","","        }","","    }","","    fclose(img);","    fclose(file);","}"]}],[{"start":{"row":0,"column":0},"end":{"row":81,"column":1},"action":"remove","lines":["#include <cs50.h>","#include <stdio.h>","#include <string.h>","#include <math.h>","#include <stdlib.h>","","//global variables","//int blocks = 1;","int count = 0;","","//functions","void recursion(int *buffer);","bool findblocks(int *buffer, FILE *file);","","int main(int argc, char *argv[])","{","    // Check usage","    if (argc != 2)","    {","        printf(\"Usage: %s image\\n\", argv[0]);","        return 1;","    }","","    int blocks = 1;","    //int *buffer = malloc(blocks*512); //malloc 512 bytes into buffer to temp store data first","    unsigned char buffer[512]; //buffer array holding 512 bytes","    char filename[8];","","    // Open file","    FILE *file = fopen(argv[1], \"r\");","","    if (!file)","    {","        printf(\"Unable to open file!\");","        return 1;","    }","","    bool firstjpg = true;","    bool jpgexists = false;","    FILE *img = NULL;","","    while(fread(buffer,512,blocks,file)==blocks)","    {","","        if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)","        {","","            if (firstjpg == true) //if it is the first jpeg","            {","                firstjpg = false;","                jpgexists = true;","            }","","            else //if firstjpg = false;","            {","                fclose(img); //if jpg exists and another jpg header is found, close previous one","                firstjpg = false;","                jpgexists = true;","            }","","","            sprintf(filename,\"%03i.jpg\",count);","            img = fopen(filename, \"w\"); //open file","            fwrite(buffer,512,1,img); //write data to it","            count++; //increase count only if header jpg are found //update with new count","","        }","","        else //if jpg header files not found","        {","            if (jpgexists == true) //& if jpg alr exists","            {","                fwrite(buffer,512,1,img); //continue writing to img","            }","","        }","","    }","","    fclose(img);","    fclose(file);","}"],"id":85},{"start":{"row":0,"column":0},"end":{"row":139,"column":0},"action":"insert","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers","","// Returns true if word from text file is in dictionary else false","//char *word = string word","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    strcasecmp(word, node->word)","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word","unsigned int hash(const char *word) //2nd","{","    int index = 0;","","    for (i = 0; i < strlength(word); i++) //run through each character of the word","    {","        word[index];//","    }","//should return an integer that indicates the position of table pointer","    return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return 1;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return 1;","        }","","        strcopy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //table[index] = n; //assign it as a temporary header. if u assign it as a header, it will lose its link","","        //loop through all the linked pointers","        //table[index] is the header node","        node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        n->next = tmp->next;","        table[index]->next = n->next;","        ","        for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            //update pointer","            n->next = tmp->next;","            table[index]->next = n->next;","","        }","","","        //add new node to that linked list","","","    }","","","","","","","    fclose(file);","","    //when fully loaded all words, return true.","","","    return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    // TODO","    return 0;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","    // TODO","    return false;","}",""]}],[{"start":{"row":139,"column":0},"end":{"row":140,"column":0},"action":"insert","lines":["",""],"id":86},{"start":{"row":140,"column":0},"end":{"row":141,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":141,"column":0},"end":{"row":153,"column":8},"action":"insert","lines":["    for (int i = 0; i < N; i++)","    {","        table[i] = malloc(sizeof(node)); //malloc for header","","        if (table[i]==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return 1;","        }","        table[i]->next = NULL;","        ","        strcpy(table[i]->word, &c); //temp allocate header as word receives from dictionary","    }   "],"id":87}],[{"start":{"row":140,"column":0},"end":{"row":140,"column":1},"action":"insert","lines":["/"],"id":88},{"start":{"row":140,"column":1},"end":{"row":140,"column":2},"action":"insert","lines":["/"]},{"start":{"row":140,"column":2},"end":{"row":140,"column":3},"action":"insert","lines":["/"]},{"start":{"row":140,"column":3},"end":{"row":140,"column":4},"action":"insert","lines":["/"]},{"start":{"row":140,"column":4},"end":{"row":140,"column":5},"action":"insert","lines":["/"]},{"start":{"row":140,"column":5},"end":{"row":140,"column":6},"action":"insert","lines":["/"]},{"start":{"row":140,"column":6},"end":{"row":140,"column":7},"action":"insert","lines":["/"]},{"start":{"row":140,"column":7},"end":{"row":140,"column":8},"action":"insert","lines":["/"]},{"start":{"row":140,"column":8},"end":{"row":140,"column":9},"action":"insert","lines":["/"]},{"start":{"row":140,"column":9},"end":{"row":140,"column":10},"action":"insert","lines":["/"]},{"start":{"row":140,"column":10},"end":{"row":140,"column":11},"action":"insert","lines":["/"]},{"start":{"row":140,"column":11},"end":{"row":140,"column":12},"action":"insert","lines":["/"]},{"start":{"row":140,"column":12},"end":{"row":140,"column":13},"action":"insert","lines":["/"]},{"start":{"row":140,"column":13},"end":{"row":140,"column":14},"action":"insert","lines":["/"]},{"start":{"row":140,"column":14},"end":{"row":140,"column":15},"action":"insert","lines":["/"]},{"start":{"row":140,"column":15},"end":{"row":140,"column":16},"action":"insert","lines":["/"]},{"start":{"row":140,"column":16},"end":{"row":140,"column":17},"action":"insert","lines":["/"]}],[{"start":{"row":0,"column":0},"end":{"row":153,"column":8},"action":"remove","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers","","// Returns true if word from text file is in dictionary else false","//char *word = string word","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    strcasecmp(word, node->word)","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word","unsigned int hash(const char *word) //2nd","{","    int index = 0;","","    for (i = 0; i < strlength(word); i++) //run through each character of the word","    {","        word[index];//","    }","//should return an integer that indicates the position of table pointer","    return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return 1;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return 1;","        }","","        strcopy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //table[index] = n; //assign it as a temporary header. if u assign it as a header, it will lose its link","","        //loop through all the linked pointers","        //table[index] is the header node","        node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        n->next = tmp->next;","        table[index]->next = n->next;","        ","        for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            //update pointer","            n->next = tmp->next;","            table[index]->next = n->next;","","        }","","","        //add new node to that linked list","","","    }","","","","","","","    fclose(file);","","    //when fully loaded all words, return true.","","","    return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    // TODO","    return 0;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","    // TODO","    return false;","}","","/////////////////","    for (int i = 0; i < N; i++)","    {","        table[i] = malloc(sizeof(node)); //malloc for header","","        if (table[i]==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return 1;","        }","        table[i]->next = NULL;","        ","        strcpy(table[i]->word, &c); //temp allocate header as word receives from dictionary","    }   "],"id":89},{"start":{"row":0,"column":0},"end":{"row":180,"column":0},"action":"insert","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <string.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include <ctype.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers/nodes","","// Returns true if word from text file is in dictionary else false","//char *word = string word","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    //strcasecmp(word, node->word)","    char c = word[0]; //obtain first character","    if (c < 97) //if uppercase","    {","        c = tolower(c); //change to lower case","    }","","    int index = c - 97; //convert to integer corresponding to hash table position","    ","    int index = hash(word);","","    //loop through every linked list to look for word","    for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","    {","        if (strcasecmp(word,tmp->word)==0)","        {","            return true;","        }","","    }","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word. (word from dictionary)","unsigned int hash(const char *word) //2nd","{","    char c = word[0]; //look at first character of string","    //all alphabets in dictionary are lower case","    int index = c - 97; //normalise characters and change to integer corresponding to positions","    //should return an integer that indicates the position of table pointer","","    return index;","","    //return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return false;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return false;","        }","","        strcpy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //loop through all the linked pointers","        //table[index] is the header node","        //header cant point to new node becus previous links will be lost","        node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        n->next = tmp->next;","        table[index]->next = n;","        //add new node to that linked list","        //keep pushing back older words and add new words behind header","        //return true;","","    }","","    fclose(file);","","    //when fully loaded all words, return true.","    return true;","","    //return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    //use hash table to determine number of words in each array","","    int counter = 0;","    //loop through hash table array","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            if (table[i]==NULL)","            {","                return 0;","            }","            counter++;","        }","    }","","    return counter;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        while (table[i] != NULL)","        {","            node *tmp = table[i]->next;","","            if (table[i]==NULL)","            {","                return false;","            }","","            free(table[i]); //free the previous link one by one","            table[i] = tmp;","        }","","        //for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        //{","            //free(tmp);","        //}","    }","    return true;","}",""]}],[{"start":{"row":0,"column":0},"end":{"row":180,"column":0},"action":"remove","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <string.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include <ctype.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers/nodes","","// Returns true if word from text file is in dictionary else false","//char *word = string word","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    //strcasecmp(word, node->word)","    char c = word[0]; //obtain first character","    if (c < 97) //if uppercase","    {","        c = tolower(c); //change to lower case","    }","","    int index = c - 97; //convert to integer corresponding to hash table position","    ","    int index = hash(word);","","    //loop through every linked list to look for word","    for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","    {","        if (strcasecmp(word,tmp->word)==0)","        {","            return true;","        }","","    }","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word. (word from dictionary)","unsigned int hash(const char *word) //2nd","{","    char c = word[0]; //look at first character of string","    //all alphabets in dictionary are lower case","    int index = c - 97; //normalise characters and change to integer corresponding to positions","    //should return an integer that indicates the position of table pointer","","    return index;","","    //return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return false;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return false;","        }","","        strcpy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //loop through all the linked pointers","        //table[index] is the header node","        //header cant point to new node becus previous links will be lost","        node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        n->next = tmp->next;","        table[index]->next = n;","        //add new node to that linked list","        //keep pushing back older words and add new words behind header","        //return true;","","    }","","    fclose(file);","","    //when fully loaded all words, return true.","    return true;","","    //return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    //use hash table to determine number of words in each array","","    int counter = 0;","    //loop through hash table array","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            if (table[i]==NULL)","            {","                return 0;","            }","            counter++;","        }","    }","","    return counter;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        while (table[i] != NULL)","        {","            node *tmp = table[i]->next;","","            if (table[i]==NULL)","            {","                return false;","            }","","            free(table[i]); //free the previous link one by one","            table[i] = tmp;","        }","","        //for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        //{","            //free(tmp);","        //}","    }","    return true;","}",""],"id":90},{"start":{"row":0,"column":0},"end":{"row":182,"column":0},"action":"insert","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <string.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include <ctype.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers/nodes","","// Returns true if word from text file is in dictionary else false","//char *word = string word","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    int index = hash(word);","","    //loop through every linked list to look for word","    for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","    {","        if (strcasecmp(word,tmp->word)==0)","        {","            return true;","        }","","    }","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word. (word from dictionary)","unsigned int hash(const char *word) //2nd","{","    char c = word[0]; //look at first character of string","    //all alphabets in dictionary are lower case","    int index = c - 97; //normalise characters and change to integer corresponding to positions","    //should return an integer that indicates the position of table pointer","","    return index;","","    //return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return false;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return false;","        }","","        strcpy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //loop through all the linked pointers","        //table[index] is the header node","        //header cant point to new node becus previous links will be lost","        //*node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        //*n->next = tmp->next;","        //*table[index]->next = n;","        //add new node to that linked list","        //keep pushing back older words and add new words behind header","","        if (table[index]==NULL) //if index array is empty, give it a new node","        {","            table[index] = n;","        }","","        else //if table is not NULL","        {","            node *tmp = table[index]->next;","            n->next = tmp;","            table[index]->next = n;","        }","","    }","","    fclose(file);","","    //when fully loaded all words, return true.","    return true;","","    //return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    //use hash table to determine number of words in each array","","    int counter = 0;","    //loop through hash table array","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            if (table[i]==NULL)","            {","                return 0;","            }","            counter++;","        }","    }","","    return counter;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        while (table[i] != NULL)","        {","            node *tmp = table[i]->next;","","            if (table[i]==NULL)","            {","                return false;","            }","","            free(table[i]); //free the previous link one by one","            table[i] = tmp;","        }","","        //for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        //{","            //free(tmp);","        //}","    }","    return true;","}",""]}],[{"start":{"row":0,"column":0},"end":{"row":182,"column":0},"action":"remove","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <string.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include <ctype.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers/nodes","","// Returns true if word from text file is in dictionary else false","//char *word = string word","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    int index = hash(word);","","    //loop through every linked list to look for word","    for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","    {","        if (strcasecmp(word,tmp->word)==0)","        {","            return true;","        }","","    }","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word. (word from dictionary)","unsigned int hash(const char *word) //2nd","{","    char c = word[0]; //look at first character of string","    //all alphabets in dictionary are lower case","    int index = c - 97; //normalise characters and change to integer corresponding to positions","    //should return an integer that indicates the position of table pointer","","    return index;","","    //return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return false;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return false;","        }","","        strcpy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //loop through all the linked pointers","        //table[index] is the header node","        //header cant point to new node becus previous links will be lost","        //*node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        //*n->next = tmp->next;","        //*table[index]->next = n;","        //add new node to that linked list","        //keep pushing back older words and add new words behind header","","        if (table[index]==NULL) //if index array is empty, give it a new node","        {","            table[index] = n;","        }","","        else //if table is not NULL","        {","            node *tmp = table[index]->next;","            n->next = tmp;","            table[index]->next = n;","        }","","    }","","    fclose(file);","","    //when fully loaded all words, return true.","    return true;","","    //return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    //use hash table to determine number of words in each array","","    int counter = 0;","    //loop through hash table array","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            if (table[i]==NULL)","            {","                return 0;","            }","            counter++;","        }","    }","","    return counter;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        while (table[i] != NULL)","        {","            node *tmp = table[i]->next;","","            if (table[i]==NULL)","            {","                return false;","            }","","            free(table[i]); //free the previous link one by one","            table[i] = tmp;","        }","","        //for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        //{","            //free(tmp);","        //}","    }","    return true;","}",""],"id":91},{"start":{"row":0,"column":0},"end":{"row":189,"column":0},"action":"insert","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <string.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include <ctype.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers/nodes","","// Returns true if word from text file is in dictionary else false","//char *word = string word in text file","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    int index = hash(word);","","    //loop through every linked list to look for word","    for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","    {","        if (strcasecmp(word,tmp->word)==0)","        {","            return true;","        }","","    }","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word. (word from dictionary)","unsigned int hash(const char *word) //2nd","{","","    char c = word[0]; //look at first character of string","    if (isalpha(c) && c < 97)//|| ispunct(c)","    {","        //if capital letters","        c = tolower(c); //change to lower case","    }","","    //all alphabets in dictionary are lower case","    int index = c - 97; //normalise characters and change to integer corresponding to positions","    //should return an integer that indicates the position of table pointer","","    return index;","","    //return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return false;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return false;","        }","","        strcpy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //loop through all the linked pointers","        //table[index] is the header node","        //header cant point to new node becus previous links will be lost","        //*node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        //*n->next = tmp->next;","        //*table[index]->next = n;","        //add new node to that linked list","        //keep pushing back older words and add new words behind header","","        if (table[index]==NULL) //if index array is empty, give it a new node","        {","            table[index] = n;","        }","","        else //if table is not NULL","        {","            node *tmp = table[index]->next;","            n->next = tmp;","            table[index]->next = n;","        }","","    }","","    fclose(file);","","    //when fully loaded all words, return true.","    return true;","","    //return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    //use hash table to determine number of words in each array","","    int counter = 0;","    //loop through hash table array","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            if (table[i]==NULL)","            {","                return 0;","            }","            counter++;","        }","    }","","    return counter;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        while (table[i] != NULL)","        {","            node *tmp = table[i]->next;","","            if (table[i]==NULL)","            {","                return false;","            }","","            free(table[i]); //free the previous link one by one","            table[i] = tmp;","        }","","        //for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        //{","            //free(tmp);","        //}","    }","    return true;","}",""]}],[{"start":{"row":0,"column":0},"end":{"row":189,"column":0},"action":"remove","lines":["// Implements a dictionary's functionality","","#include <stdbool.h>","#include <string.h>","#include <strings.h>","#include <stdio.h>","#include <stdlib.h>","#include <ctype.h>","#include \"dictionary.h\"","","// Represents a node in a hash table","typedef struct node","{","    char word[LENGTH + 1]; //character array that stores the length of the word. random access every character in word","    //e.g. char cat[3+1]: cat[0] = c; cat[1] = a; cat[2] = t","    struct node *next; //pointer that points to the next word","}","node;","","// Number of buckets in hash table","const unsigned int N = 26; //can change N","","// Hash table.","//declares table as an array of N pointers. Thus, each element in table, holds a pointer to an int value.","node *table[N]; //create an array of pointers/nodes","","// Returns true if word from text file is in dictionary else false","//char *word = string word in text file","bool check(const char *word) //4th","{","    //compare words stored in hashtable","    int index = hash(word);","","    //loop through every linked list to look for word","    for (node *tmp = table[index]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","    {","        if (strcasecmp(word,tmp->word)==0)","        {","            return true;","        }","","    }","    return false;","}","","// Hashes word to a number. take a word, run a hash function on it, return an integer","//assigns a number to every input. associate each word with a specific numbered bucket","//takes word as an input. convert this word to a number so it knows which bucket & linked list to go to.","//char *word = string word. (word from dictionary)","unsigned int hash(const char *word) //2nd","{","","    char c = word[0]; //look at first character of string","    if (isalpha(c) && c < 97)//|| ispunct(c)","    {","        //if capital letters","        c = tolower(c); //change to lower case","    }","","    //all alphabets in dictionary are lower case","    int index = c - 97; //normalise characters and change to integer corresponding to positions","    //should return an integer that indicates the position of table pointer","","    return index;","","    //return 0;","}","","// Loads dictionary into memory, returning true if successful else false","//load words into a data structure i.e. hash table","//hash table: array of linked list","//a dictionary is a list of words. so u have to hash each word in the dictionary to laod the entire dictionary","//has to call hash function","bool load(const char *dictionary) //1st","{","    // Open file","    FILE *file = fopen(dictionary, \"r\");","","    if (file==NULL)","    {","        printf(\"Unable to open file %s\\n\",dictionary);","        return false;","    }","","    char word[LENGTH + 1]; //character array","    //int index = 0 ;","    //for each string, hash it and load it into memory using hash function;","","    //read strings from file","    while (fscanf(file,\"%s\",word) != EOF)","    {","        //everytime a word is read, malloc for the node that contains the word and its node","        //create a new node for each word","        node *n = malloc(sizeof(node)); //define a temp node pointer that mallocs for node","","        if (n==NULL)","        {","            printf(\"No space for malloc!\\n\");","            return false;","        }","","        strcpy(n->word, word); //go to the word in node and copy the word into","        n->next = NULL; //idk what the next word is but dictionary is alr alphabetically ordered","","        //hash word to identify which position of hashtable it should insert into","        int index = hash(word);","","        //insert node into hashtable","        //hash table is an array of linked list","        //loop through all the linked pointers","        //table[index] is the header node","        //header cant point to new node becus previous links will be lost","        //*node *tmp = table[index]; //assign a temp to point whereever header is pointing at","        //update pointer","        //*n->next = tmp->next;","        //*table[index]->next = n;","        //add new node to that linked list","        //keep pushing back older words and add new words behind header","","        if (table[index]==NULL) //if index array is empty, give it a new node","        {","            table[index] = n;","        }","","        else //if table is not NULL","        {","            node *tmp = table[index]->next;","            n->next = tmp;","            table[index]->next = n;","        }","","    }","","    fclose(file);","","    //when fully loaded all words, return true.","    return true;","","    //return false;","}","","// Returns number of words in dictionary if loaded else 0 if not yet loaded","unsigned int size(void) //3rd","{","    //use hash table to determine number of words in each array","","    int counter = 0;","    //loop through hash table array","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        {","            if (table[i]==NULL)","            {","                return 0;","            }","            counter++;","        }","    }","","    return counter;","}","","// Unloads dictionary from memory, returning true if successful else false","bool unload(void) //5th","{","","    for (int i = 0; i < N; i++)","    {//loop through each linked list in each array","        while (table[i] != NULL)","        {","            node *tmp = table[i]->next;","","            if (table[i]==NULL)","            {","                return false;","            }","","            free(table[i]); //free the previous link one by one","            table[i] = tmp;","        }","","        //for (node *tmp = table[i]; tmp != NULL; tmp = tmp->next)//continue loop if pointer is not NULL","        //{","            //free(tmp);","        //}","    }","    return true;","}",""],"id":92},{"start":{"row":0,"column":0},"end":{"row":17,"column":24},"action":"insert","lines":["    sum1 = sum(list2) #add all the elements in list2","    index_last = len(card) - 1","","    while index_last >= 0:","        list3.append(int(card[index_last]))","        index_last -= 2","    total_sum = sum(list3) + sum1","    total_sum = str(total_sum) #convert it to string then access the last digit","    last_digit = int(total_sum[1])","","    if last_digit == 0 and int(card[0]) == 4:","        print(\"VISA\")","    elif last_digit == 0 and (int(card[0:2]) >= 51 or int(card[0:2]) <= 55):","        print(\"MASTERCARD\")","    elif last_digit == 0 and (int(card[0:2]) == 34 or int(card[0:2]) == 37):","        print(\"AMEX\")","    else:","        print(\"INVALID\")"]}],[{"start":{"row":0,"column":4},"end":{"row":1,"column":0},"action":"insert","lines":["",""],"id":93},{"start":{"row":1,"column":0},"end":{"row":1,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":0,"column":0},"end":{"row":5,"column":27},"action":"insert","lines":["    for i in list2:","        #if list2[i] >= 10: #if number exceeds 10 (it will not exceed 20)","            #r = list2[i]%10","            #sum = 1 + r","            #list2[i] = sum","            print(list2[i])"],"id":94}],[{"start":{"row":5,"column":27},"end":{"row":5,"column":31},"action":"remove","lines":["    "],"id":95},{"start":{"row":5,"column":27},"end":{"row":6,"column":0},"action":"insert","lines":["",""]},{"start":{"row":6,"column":0},"end":{"row":6,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":0},"action":"insert","lines":["",""],"id":96},{"start":{"row":1,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":0,"column":0},"end":{"row":7,"column":23},"action":"insert","lines":["    index = len(card) - 1 #len(card) - 1 is indexing last number","    while (index >= 0):","        list1.append(int(card[index]))","        index -= 2","","    #list2 = [i * 2 for i in list1] #multiply every element in list by 2","    for i in list1:","        print(list1[i])"],"id":97}],[{"start":{"row":0,"column":0},"end":{"row":33,"column":24},"action":"remove","lines":["    index = len(card) - 1 #len(card) - 1 is indexing last number","    while (index >= 0):","        list1.append(int(card[index]))","        index -= 2","","    #list2 = [i * 2 for i in list1] #multiply every element in list by 2","    for i in list1:","        print(list1[i])","","    for i in list2:","        #if list2[i] >= 10: #if number exceeds 10 (it will not exceed 20)","            #r = list2[i]%10","            #sum = 1 + r","            #list2[i] = sum","            print(list2[i])","            ","    sum1 = sum(list2) #add all the elements in list2","    index_last = len(card) - 1","","    while index_last >= 0:","        list3.append(int(card[index_last]))","        index_last -= 2","    total_sum = sum(list3) + sum1","    total_sum = str(total_sum) #convert it to string then access the last digit","    last_digit = int(total_sum[1])","","    if last_digit == 0 and int(card[0]) == 4:","        print(\"VISA\")","    elif last_digit == 0 and (int(card[0:2]) >= 51 or int(card[0:2]) <= 55):","        print(\"MASTERCARD\")","    elif last_digit == 0 and (int(card[0:2]) == 34 or int(card[0:2]) == 37):","        print(\"AMEX\")","    else:","        print(\"INVALID\")"],"id":98},{"start":{"row":0,"column":0},"end":{"row":60,"column":13},"action":"insert","lines":["import csv","import re","from cs50 import get_string","import sys","","# Check for correct number of args","if len(sys.argv) != 3:","    print(\"Usage: [csv] & [txt]\")","    sys.exit(1)","","database = sys.argv[1]","txt = sys.argv[2]","","# Open CSV file","database = open(database, mode='r')","database = csv.DictReader(database)","#The first line of the CSV file is assumed to contain the keys to use to build the dictionary.","#for row in database:","        #print(row['name'],row['AGATC'])","        #if row['AGATC'] in sequence etc.. print row['name']","#AGATC,TTTTTTCT,AATG,TCTAG,GATA,TATC,GAAA,TCTG","sequences = open(txt, mode=\"r\")","if sequences.mode == 'r':","    sequences = sequences.read()","    #print(sequences)","fieldnames = database.fieldnames #get fieldnames","#del fieldnames[0] #delete the field 'name'","#agatc = re.search(\"(AGATC){2}\",sequences)","dna_sequence = fieldnames[1:]","count_sequences = [sequences.count(i) for i in dna_sequence] #remove the first field","print(fieldnames,count_sequences,dna_sequence)","","for row in database:","        #print(row) #maps the information in each row to a dict","        slice_row = {fieldnames:row[fieldnames] for fieldnames in dna_sequence if fieldnames in row} #dict","        identity = row.get('name')","        slice_row = list(slice_row.values())","        slice_row = [int(i) for i in slice_row]","        print(slice_row)","        #if count_sequences == slice_row:","            #print(identity)","        #else:","            #print(\"No match\")","","for row in database:","    if \"Bob\" == row['name']:","        print(\"Bob\")","#while(n<len(sequences)):","    #agatc = re.search(\"(AGATC){n}\",sequences) #(...)Matches whatever regular expression is inside the parentheses","    #if agatc != None:","        #print(n)","    #n+=1","#agatc = re.search(\"(AGATC){2}\",sequences)","#re.findall(pattern, string, flags=0),matches are returned in the order found.","#agatc = sequences.count(\"AGATC\")","#aatg = sequences.count(\"AATG\")","#tatc = sequences.count(\"TATC\")","#ttttttct = sequences.count(\"TTTTTTCT\")","#tctag = sequences.count(\"TTTTTTCT\")","#print(agatc, aatg, tatc)","#print(agatc)"]}],[{"start":{"row":0,"column":0},"end":{"row":60,"column":13},"action":"remove","lines":["import csv","import re","from cs50 import get_string","import sys","","# Check for correct number of args","if len(sys.argv) != 3:","    print(\"Usage: [csv] & [txt]\")","    sys.exit(1)","","database = sys.argv[1]","txt = sys.argv[2]","","# Open CSV file","database = open(database, mode='r')","database = csv.DictReader(database)","#The first line of the CSV file is assumed to contain the keys to use to build the dictionary.","#for row in database:","        #print(row['name'],row['AGATC'])","        #if row['AGATC'] in sequence etc.. print row['name']","#AGATC,TTTTTTCT,AATG,TCTAG,GATA,TATC,GAAA,TCTG","sequences = open(txt, mode=\"r\")","if sequences.mode == 'r':","    sequences = sequences.read()","    #print(sequences)","fieldnames = database.fieldnames #get fieldnames","#del fieldnames[0] #delete the field 'name'","#agatc = re.search(\"(AGATC){2}\",sequences)","dna_sequence = fieldnames[1:]","count_sequences = [sequences.count(i) for i in dna_sequence] #remove the first field","print(fieldnames,count_sequences,dna_sequence)","","for row in database:","        #print(row) #maps the information in each row to a dict","        slice_row = {fieldnames:row[fieldnames] for fieldnames in dna_sequence if fieldnames in row} #dict","        identity = row.get('name')","        slice_row = list(slice_row.values())","        slice_row = [int(i) for i in slice_row]","        print(slice_row)","        #if count_sequences == slice_row:","            #print(identity)","        #else:","            #print(\"No match\")","","for row in database:","    if \"Bob\" == row['name']:","        print(\"Bob\")","#while(n<len(sequences)):","    #agatc = re.search(\"(AGATC){n}\",sequences) #(...)Matches whatever regular expression is inside the parentheses","    #if agatc != None:","        #print(n)","    #n+=1","#agatc = re.search(\"(AGATC){2}\",sequences)","#re.findall(pattern, string, flags=0),matches are returned in the order found.","#agatc = sequences.count(\"AGATC\")","#aatg = sequences.count(\"AATG\")","#tatc = sequences.count(\"TATC\")","#ttttttct = sequences.count(\"TTTTTTCT\")","#tctag = sequences.count(\"TTTTTTCT\")","#print(agatc, aatg, tatc)","#print(agatc)"],"id":99},{"start":{"row":0,"column":0},"end":{"row":59,"column":13},"action":"insert","lines":["import csv","import re","from cs50 import get_string","import sys","","# Check for correct number of args","if len(sys.argv) != 3:","    print(\"Usage: [csv] & [txt]\")","    sys.exit(1)","","database = sys.argv[1]","txt = sys.argv[2]","","# Open CSV file","database = open(database, mode='r')","database = csv.DictReader(database)","#The first line of the CSV file is assumed to contain the keys to use to build the dictionary.","#for row in database:","        #print(row['name'],row['AGATC'])","        #if row['AGATC'] in sequence etc.. print row['name']","#AGATC,TTTTTTCT,AATG,TCTAG,GATA,TATC,GAAA,TCTG","sequences = open(txt, mode=\"r\")","if sequences.mode == 'r':","    sequences = sequences.read()","    #print(sequences)","fieldnames = database.fieldnames #get fieldnames","#del fieldnames[0] #delete the field 'name'","#agatc = re.search(\"(AGATC){2}\",sequences)","dna_sequence = fieldnames[1:]","count_sequences = [sequences.count(i) for i in dna_sequence] #remove the first field","#print(fieldnames,count_sequences,dna_sequence)","","def match_sequence(dictionary):","    for row in database:","        #print(row) #maps the information in each row to a dict","        slice_row = {fieldnames:row[fieldnames] for fieldnames in dna_sequence if fieldnames in row} #dict","        identity = row.get('name')","        slice_row = list(slice_row.values())","        slice_row = [int(i) for i in slice_row]","        #print(slice_row)","        if count_sequences == slice_row:","            print(identity)","        else:","            print(\"No match\")","","","#while(n<len(sequences)):","    #agatc = re.search(\"(AGATC){n}\",sequences) #(...)Matches whatever regular expression is inside the parentheses","    #if agatc != None:","        #print(n)","    #n+=1","#agatc = re.search(\"(AGATC){2}\",sequences)","#re.findall(pattern, string, flags=0),matches are returned in the order found.","#agatc = sequences.count(\"AGATC\")","#aatg = sequences.count(\"AATG\")","#tatc = sequences.count(\"TATC\")","#ttttttct = sequences.count(\"TTTTTTCT\")","#tctag = sequences.count(\"TTTTTTCT\")","#print(agatc, aatg, tatc)","#print(agatc)"]}],[{"start":{"row":0,"column":0},"end":{"row":59,"column":13},"action":"remove","lines":["import csv","import re","from cs50 import get_string","import sys","","# Check for correct number of args","if len(sys.argv) != 3:","    print(\"Usage: [csv] & [txt]\")","    sys.exit(1)","","database = sys.argv[1]","txt = sys.argv[2]","","# Open CSV file","database = open(database, mode='r')","database = csv.DictReader(database)","#The first line of the CSV file is assumed to contain the keys to use to build the dictionary.","#for row in database:","        #print(row['name'],row['AGATC'])","        #if row['AGATC'] in sequence etc.. print row['name']","#AGATC,TTTTTTCT,AATG,TCTAG,GATA,TATC,GAAA,TCTG","sequences = open(txt, mode=\"r\")","if sequences.mode == 'r':","    sequences = sequences.read()","    #print(sequences)","fieldnames = database.fieldnames #get fieldnames","#del fieldnames[0] #delete the field 'name'","#agatc = re.search(\"(AGATC){2}\",sequences)","dna_sequence = fieldnames[1:]","count_sequences = [sequences.count(i) for i in dna_sequence] #remove the first field","#print(fieldnames,count_sequences,dna_sequence)","","def match_sequence(dictionary):","    for row in database:","        #print(row) #maps the information in each row to a dict","        slice_row = {fieldnames:row[fieldnames] for fieldnames in dna_sequence if fieldnames in row} #dict","        identity = row.get('name')","        slice_row = list(slice_row.values())","        slice_row = [int(i) for i in slice_row]","        #print(slice_row)","        if count_sequences == slice_row:","            print(identity)","        else:","            print(\"No match\")","","","#while(n<len(sequences)):","    #agatc = re.search(\"(AGATC){n}\",sequences) #(...)Matches whatever regular expression is inside the parentheses","    #if agatc != None:","        #print(n)","    #n+=1","#agatc = re.search(\"(AGATC){2}\",sequences)","#re.findall(pattern, string, flags=0),matches are returned in the order found.","#agatc = sequences.count(\"AGATC\")","#aatg = sequences.count(\"AATG\")","#tatc = sequences.count(\"TATC\")","#ttttttct = sequences.count(\"TTTTTTCT\")","#tctag = sequences.count(\"TTTTTTCT\")","#print(agatc, aatg, tatc)","#print(agatc)"],"id":100},{"start":{"row":0,"column":0},"end":{"row":16,"column":54},"action":"insert","lines":["balance = db.execute(\"SELECT (cash) FROM users WHERE username = :username\",","                          username=user_id)","        balance = balance[0][\"cash\"]","        balance = balance - total_share_stock","","        print(user_id, balance)","","        #create table if it doesnt exist","        db.execute(\"CREATE TABLE IF NOT EXISTS shares (username VARCHAR(255), symbol VARCHAR(10), shares INT, price REAL, time TEXT)\")","","        if total_share_stock > balance:","            return apology(\"you don't have enough money\", 403)","        else:","            db.execute(\"INSERT INTO shares (username, symbol, shares, price, time) VALUES (:username, :symbol, :shares, :price, :time)\",","                user_id, symbol_stock, share_stock, price_stock, datetime.datetime.now())","            db.execute(\"UPDATE users SET cash = :balance WHERE username = :username\",","                balance = balance, username = user_id)"]}],[{"start":{"row":16,"column":54},"end":{"row":17,"column":0},"action":"insert","lines":["",""],"id":101},{"start":{"row":17,"column":0},"end":{"row":17,"column":16},"action":"insert","lines":["                "]}],[{"start":{"row":17,"column":12},"end":{"row":17,"column":16},"action":"remove","lines":["    "],"id":102}],[{"start":{"row":17,"column":12},"end":{"row":18,"column":0},"action":"insert","lines":["        render_template(\"bought.html\", symbol_stock = symbol_stock, name_stock = name_stock, share_stock = share_stock, price_stock = price_stock, total_share_stock = total_share_stock, balance = total_share_stock)",""],"id":103}],[{"start":{"row":17,"column":16},"end":{"row":17,"column":20},"action":"remove","lines":["    "],"id":104},{"start":{"row":17,"column":12},"end":{"row":17,"column":16},"action":"remove","lines":["    "]}],[{"start":{"row":0,"column":0},"end":{"row":18,"column":0},"action":"remove","lines":["balance = db.execute(\"SELECT (cash) FROM users WHERE username = :username\",","                          username=user_id)","        balance = balance[0][\"cash\"]","        balance = balance - total_share_stock","","        print(user_id, balance)","","        #create table if it doesnt exist","        db.execute(\"CREATE TABLE IF NOT EXISTS shares (username VARCHAR(255), symbol VARCHAR(10), shares INT, price REAL, time TEXT)\")","","        if total_share_stock > balance:","            return apology(\"you don't have enough money\", 403)","        else:","            db.execute(\"INSERT INTO shares (username, symbol, shares, price, time) VALUES (:username, :symbol, :shares, :price, :time)\",","                user_id, symbol_stock, share_stock, price_stock, datetime.datetime.now())","            db.execute(\"UPDATE users SET cash = :balance WHERE username = :username\",","                balance = balance, username = user_id)","            render_template(\"bought.html\", symbol_stock = symbol_stock, name_stock = name_stock, share_stock = share_stock, price_stock = price_stock, total_share_stock = total_share_stock, balance = total_share_stock)",""],"id":105},{"start":{"row":0,"column":0},"end":{"row":56,"column":0},"action":"insert","lines":["@app.route(\"/buy\", methods=[\"GET\", \"POST\"])","@login_required","def buy():","    \"\"\"Buy shares of stock\"\"\"","","    user_id = int(session.get(\"user_id\"))","    symbol_net_share = db.execute(\"SELECT DISTINCT symbol, SUM(shares) as netshare FROM shares WHERE id = :user_id GROUP BY symbol\", user_id = user_id)","","","    if request.method == \"GET\":","        return render_template(\"buy.html\", symbol_net_share = symbol_net_share)","","    else:","        if not request.form.get(\"symbol\"):","            return apology(\"must provide stock's symbol\", 403)","        elif lookup(request.form.get(\"symbol\")) == None:","            return apology(\"stock does not exist\", 403)","        elif not request.form.get(\"shares\"):","            return apology(\"must provide stock's share\", 403)","        elif int(request.form.get(\"shares\")) <= 0:","            return apology(\"must provide positive integer\", 403)","","        #if all clear, lookup stocks","        stocks = lookup(request.form.get(\"symbol\"))","        #get stock price","        price_stock = stocks[\"price\"]","        price_stock = round(int(price_stock), 2)","        symbol_stock = stocks[\"symbol\"]","        name_stock = stocks[\"name\"]","        #get no. of share","        share_stock = int(request.form.get(\"shares\"))","        #get total stock price","        total_share_stock = share_stock * price_stock","        #check with user's balance","","","        balance = db.execute(\"SELECT (cash) FROM users WHERE id = :user_id\",","                          user_id=user_id)","        balance = balance[0][\"cash\"]","        balance = round(balance - total_share_stock,2)","","        #create table if it doesnt exist","        db.execute(\"CREATE TABLE IF NOT EXISTS shares (id INT, symbol VARCHAR(10), shares INT, price REAL, time TEXT)\")","","        if total_share_stock > balance:","            return apology(\"you don't have enough money\", 403)","        else:","            db.execute(\"INSERT INTO shares (id, symbol, shares, price, time) VALUES (:user_id, :symbol, :shares, :price, :time)\",","                user_id = user_id, symbol = symbol_stock, shares = share_stock, price = price_stock, time = datetime.datetime.now())","            db.execute(\"UPDATE users SET cash = :balance WHERE id = :user_id\",","                balance = balance, user_id = user_id)","            return render_template(\"bought.html\", symbol_stock = symbol_stock, name_stock = name_stock,","            share_stock = share_stock, price_stock = price_stock, total_share_stock = total_share_stock, balance = balance)","","","",""]}],[{"start":{"row":56,"column":0},"end":{"row":66,"column":9},"action":"insert","lines":["var dropdown = document.getElementById(\"dropdown\")","","        var typebox = document.getElementById(\"textbox\")","","        document.querySelector('#textbox').onkeyup = function() {","            if (document.querySelector('#textbox').value !== '') { //if not blank, then disable dropdown","                dropdown.disabled = true;","            } else {","                dropdown.disabled = false; //if textbox is blank, enable dropdown","            }","        }"],"id":106}]]},"ace":{"folds":[],"scrolltop":739.5,"scrollleft":0,"selection":{"start":{"row":61,"column":12},"end":{"row":61,"column":64},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":45,"state":"start","mode":"ace/mode/text"}},"timestamp":1584946296941}